<?xml version="1.0"?>

<!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "../project.dtd">

<!--
 !   SPLAT build file
 !
 !   This file describes how to build the SPLAT package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !   In addition SPLAT may have requirements for other "core" and
 !   "third-party" packages to complete the compilation and any
 !   testing.
 !
 !   The main targets are:
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> configures the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      javadoc-sources  -> make source files for release API documention
 !      build-lineids    -> create the distributable line identifier jar file
 !      build-native     -> builds native library for current platform
 !      test             -> run up SPLAT from local build
 !
 !   Authors:
 !      Peter W. Draper (26-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for SPLAT" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar and shareable library tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- URL and package-list for linking against full Java docs -->
  <property name="javaapi.url" value="http://docs.oracle.com/javase/6/docs/api/"/>
  <property name="javaapi.lis" value="${star.build.dir}/src/docs/javaapi/"/>

  <!-- Web proxy configuration, you will usually override these in
   !   ~/.stardev.properties or .properties -->
  <property name="http.proxyPort" value="8080"/>
  <property name="http.proxyHost" value=""/>

  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="SPLAT-VO"/>
  <property name="name" value="splat"/>
  <property name="version" value="3.11-6"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink.splat"/>


  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>
  <property name="source.version" value="1.6"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="yes"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="${basedir}/src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing miscellaneous docs -->
  <property name="src.docs" value="${src.dir}/docs"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directory containing JNI source code -->
  <property name="src.jni.dir" value="${src.dir}/jni"/>

  <!-- Directory for miscellaneous files -->
  <property name="src.etc" value="${src.dir}/etc"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico,**/JavaHelpSearch/*"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>
  <property name="build.jni" value="${build.dir}/jni"/>
  <property name="build.lib" location="${build.dir}/lib"/>
  <property name="build.examples" value="${build.classes}/examples"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants. Note some build components may
   !   be placed directly here for efficiency-->
  <property name="dist.dir" value="${basedir}"/>
  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.bin}/${name}"/>
  <property name="dist.lib.pkg" value="${dist.lib}/${name}"/>
  <property name="dist.docs.pkg" value="${dist.docs}/${name}"/>
  <property name="dist.etc.pkg" value="${dist.etc}/${name}"/>
  <property name="dist.javadocs" value="${dist.docs}/${name}/javadocs"/>

  <!-- Architecture-specific files (shared libraries) will be placed in
   !   an appropriate subdirectory of dist.lib -->
  <property name="dist.lib.arch" value="${dist.lib}/${os.arch}"/>
  <property name="src.lib.arch" value="${src.jars.dir}/${os.arch}"/>
  <property name="build.lib.arch" value="${build.lib}/${os.arch}"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Local webstart properties. Note this needs a local keystore,
   !   assumed to be called keystore in $star.build.dir, .. by
   !   default. -->
  <property name="webstart.codebase"
            value="http://starlink.jach.hawaii.edu/starjava/lib"/>
  <property name="webstart.alias" value="Starlink-UK"/>
  <property name="webstart.keystore" value="${star.build.dir}/keystore"/>
  <property name="webstart.keypass" value="Vroomfondel"/>
  <property name="webstart.storepass" value="Majikthise"/>
  <property name="webstart.starlink_logo" value="starlink_logo_med.gif"/>
  <property name="home.page" value="http://www.starlink.ac.uk/${name}"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="stardev" value="/star"/>

  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally built
   !   class files in preference to installed ones (an extra user-define
   !   defined CLASSPATH can also be used as needed).
   !-->
  <path id="installed.classpath">

    <!-- JNIAST -->
    <pathelement location="${star.jar.dir}/jniast/jniast.jar"/>

    <!-- NDArray-->
    <pathelement location="${star.jar.dir}/array/array.jar"/>

    <!-- DIVA -->
    <pathelement location="${star.jar.dir}/diva/diva.jar"/>

    <!-- HDX -->
    <pathelement location="${star.jar.dir}/hdx/hdx.jar"/>

    <!-- SOAPSERVER -->
    <pathelement location="${star.jar.dir}/soapserver/soapserver.jar"/>

    <!-- PAL -->
    <pathelement location="${star.jar.dir}/pal/pal.jar"/>

    <!-- ASTGUI -->
    <pathelement location="${star.jar.dir}/astgui/astgui.jar"/>

    <!-- TABLE -->
    <pathelement location="${star.jar.dir}/table/table.jar"/>

    <!-- VOTable -->
    <pathelement location="${star.jar.dir}/votable/votable.jar"/>

    <!-- VO -->
    <pathelement location="${star.jar.dir}/vo/vo.jar"/>

    <!-- PLASTIC -->
    <pathelement location="${star.jar.dir}/plastic/plastic.jar"/>

    <!-- HDS -->
    <pathelement location="${star.jar.dir}/hds/hds.jar"/>

    <!-- DATANODE -->
    <pathelement location="${star.jar.dir}/datanode/datanode.jar"/>

    <!-- JSKY -->
    <pathelement location="${star.jar.dir}/jsky/jsky.jar"/>

    <!-- HELP -->
    <pathelement location="${star.jar.dir}/help/help.jar"/>

    <!-- UTIL -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

  </path>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that building a
   !   classpath based on their manifest class-paths will not resolve
   !   all references (these may be to other third party jars, that
   !   are normally resolved using relative URLs). The way that this
   !   is resolved is simply to locate all "build/classes" directories
   !   and all jar files in the "dist" parts and just add these all
   !   to the classpath. Known third party dependencies are added
   !   after the "build/classes" directories using the "extclasspath"
   !   type, just so that they will be referred to first. If this
   !   doesn't work as expected add the additional classes/jars to
   !   the extra classpath.
   !-->
  <path id="built.jarpath">
    <pathelement location="${star.build.dir}/array/lib/array/array.jar"/>
    <pathelement location="${star.build.dir}/jniast/lib/jniast/jniast.jar"/>
    <pathelement location="${star.build.dir}/hdx/lib/hdx/hdx.jar"/>
    <pathelement location="${star.build.dir}/diva/lib/diva/diva.jar"/>
    <pathelement location="${star.build.dir}/soapserver/lib/soapserver/soapserver.jar"/>
    <pathelement location="${star.build.dir}/pal/lib/pal/pal.jar"/>
    <pathelement location="${star.build.dir}/astgui/lib/astgui/astgui.jar"/>
    <pathelement location="${star.build.dir}/table/lib/table/table.jar"/>
    <pathelement location="${star.build.dir}/votable/lib/votable/votable.jar"/>
    <pathelement location="${star.build.dir}/vo/lib/vo/vo.jar"/>
    <pathelement location="${star.build.dir}/plastic/lib/plastic/plastic.jar"/>
    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
  </path>

  <!-- Local third party jars. Normally these will be kept in their
   !   own third party package, but may be kept here temporarily, so
   !   if there are version conflicts that cannot be addressed.
   !   They are installed with the package jar files and should be
   !   entered into the main jar file manifest.
   !-->
  <path id="package.jars">
     <fileset dir="${src.jars.dir}">
        <include name="*.jar"/>
     </fileset>
  </path>

  <path id="built.classpath">

    <!-- Local third party jars -->
    <path refid="package.jars"/>

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Local line identifiers -->
    <pathelement location="${build.dir}/ids"/>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional URL resolving mechanism-->

  </path>

  <!-- Extra user-defined classpath. This is set by the property
   !   "extra.class.path" (which can be defined locally using say
   !   -Dextra.class.path=$CLASSPATH on the command line or by setting
   !   the property in either of the properties files.-->
  <property name="extra.class.path" value=""/>
  <path id="local.classpath" path="${extra.class.path}"/>

  <!-- Unification of all classpaths using extra, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!-- Locate the JNI libraries for this platform. -->
  <path id="jni-ldpath.id">
    <pathelement path="${java.library.path}"/>
    <pathelement path="${dist.lib.arch}"/>
    <pathelement path="${star.jar.dir}/${os.arch}"/>
    <pathelement path="${star.build.dir}/jniast/lib/${os.arch}"/>
    <pathelement path="${star.build.dir}/jnihds/lib/${os.arch}"/>
  </path>
  <property name="jni-ldpath" refid="jni-ldpath.id"/>

  <!--
   !    ===========================================
   !    Check availability of optional dependencies
   !    ===========================================
   !
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need JUnit for testcases, not essential -->
    <available property="junit.present"
               classpathref="classpath"
               classname="junit.framework.TestCase"/>
  </target>


  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>

  <!--
  !   ==============
  !   Build the code
  !   ==============
  !
  !  The results of the compilation are placed in the build.classes
  !  directory. Other files that are also needed in the classes tree
  !  (i.e. resources like images) should also be copied into place here.
  !-->
  <target name="build"
          depends="prepare, check_packages, build_examples, unpack_jni"
          unless="runonly.install"
          description="-> compiles the source code">

    <javac srcdir="${java.dir}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}"
           source="${source.version}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
      <exclude name="**/*Test*"/>
      <exclude name="**/ExtractNDFWCS2XML.java"/>
    </javac>

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}">
        <include name="**/deploy.wsdd"/>
        <include name="**/*.xml"/>
        <include name="**/images/**"/>
      </fileset>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <mkdir dir="${dist.lib.pkg}"/>
    <copy todir="${dist.lib.pkg}">
       <fileset dir="${src.jars.dir}" includes="*">
        <and>
          <type type="file"/>
        </and>
      </fileset>
    </copy>

    <!-- Update the version properties file. Keep copy in real source for
     !   reference, but do not copy that into place. -->
    <echo file="${java.dir}/uk/ac/starlink/splat/util/splat.version"
          message="version=${version}${line.separator}"/>
    <mkdir dir="${build.classes}"/>
    <echo file="${build.classes}/uk/ac/starlink/splat/util/splat.version"
          message="version=${version}${line.separator}"/>


    <!-- Update the line identifier database. -->
    <uptodate property="lineids.notrequired"
              targetfile="${dist.lib.pkg}/splat_lines.jar">
      <srcfiles dir="${src.etc}/ids"/>
    </uptodate>
    <antcall target="build-lineids"/>
  </target>

  <!--
   !   =======================
   !   Create line id jar file
   !   =======================
   !
   !  Creates the jar file that contains the line identifiers. This
   !  is required when new files are added to the database.
   !-->
  <target name="build-lineids"
          unless="lineids.notrequired"
          description="-> create the distributable line identifier jar file" >

    <!-- Make the mirror tree with the pre-processed spectra, note
     !   requires JNIAST to be available for the current platform, so
     !   we set the LD_LIBRARY_PATH. Fail if doesn't work, don't want
     !   a corrupt jar file. -->
    <java classname="uk.ac.starlink.splat.util.LineIDTree" failonerror="true" fork="true">
      <classpath refid="classpath"/>
      <sysproperty key="java.library.path" value="${jni-ldpath}"/>
      <arg value="${src.etc}/ids"/>
      <arg value="${build.dir}/ids/ids"/>
      <jvmarg value="-Djava.awt.headless=true"/>
    </java>

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/splat_lines.jar"
         basedir="${build.dir}/ids"/>

  </target>

  <!--
   !   =============================
   !   Copy example data into place.
   !   =============================
   !-->
  <target name="build_examples">

    <mkdir dir="${build.examples}"/>
    <copy todir="${build.examples}">
      <fileset dir="${src.etc}/examples" includes="*">
        <and>
          <type type="file"/>
        </and>
      </fileset>
    </copy>

  </target>

  <!-- Pulls the architecture-specific shared libraries out of the source
   !   jar files in which they live.  These jar files are in the CVS
   !   repository, they are not built as part of the normal build target.
   !   The one specific to the build-time architecture can be built
   !   using the 'build-native' target, but this requires more than the
   !   basic CVS files to work (e.g. it needs the stardev classic libraries).
   !-->
  <target name="unpack_jni" unless="unpack.skip">
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="i386"/>
    </antcall>
<!--  removed old stuff 
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="sparc"/>
    </antcall>
-->
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86"/>
    </antcall>
<!--  removed old stuff 
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="ppc"/>
    </antcall>
-->
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="amd64"/>
    </antcall>
    <antcall target="unpack_jni_arch">
      <param name="unpack.arch" value="x86_64"/>
    </antcall>
  </target>

  <!-- Architecture-specific JNI jar file unpacker, skips if jar file
   !   missing -->
  <target name="unpack_jni_arch">
    <unjar dest="${dist.lib}/${unpack.arch}">
      <fileset file="${src.jars.dir}/${unpack.arch}/${name}_libs.jar"/>
      <patternset excludes="META-INF*/*"/>
    </unjar>
  </target>


  <!--
   !  ============================================
   !  Build the native shared library from sources
   !  ============================================
   !
   !  This does the actual build of the shared library for the build-time
   !  architecture, and requires a stardev installation.  It is not a
   !  dependency of any of the other public targets, and should not be
   !  invoked as part of the normal build process.  It should be invoked
   !  periodically (when NDF or the local C source change), once on each
   !  of the supported platforms, and the resulting new 'source' files
   !  (shared library jar files) checked in.
   !
   !  Note the build will not be attempted if the stardev property is not set.
   !-->
  <target name="build-native"
          description="-> builds native library">

    <!-- Extract the existing libraries from the jar file. There may
     !   be more than one library per architecture (i386 Linux and OS X)
     !   and we want to keep the other libraries. The datestamps should
     !   be in the past otherwise this will fail
     !-->
    <unjar dest="${build.lib.arch}">
      <fileset file="${src.lib.arch}/${name}_libs.jar"/>
    </unjar>

    <!-- Build the library -->
    <antcall target="execute_mk_script">
      <param name="mk.action" value="build"/>
    </antcall>

    <!-- Jar it up and copy it into the source tree ready for CVS checkin -->
    <jar destfile="${src.lib.arch}/${name}_libs.jar"
         basedir="${build.lib.arch}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
      </manifest>
    </jar>
  </target>

  <!--
   !  ===================================
   !  Execute shareable library MK script
   !  ===================================
   !
   !  Execute the "mk" script that creates the package shareable
   !  library. The action performed is controlled by the "mk.action"
   !  property that should be defined before an antcall to this
   !  target.
   !-->
  <target name="execute_mk_script">

    <!-- Before proceeding use a simple test to estimate if this
     !   may succeed. A failure isn't critical as SPLAT can use
     !   NDX support (available via JNIHDS) to access NDFs.
     !-->
     <available file="${stardev}/bin/ndf_link" type="file"
                property="stardev.exists"/>

     <!-- Only one of these executes, depending on whether "stardev.exists" is
      !   defined -->
     <antcall target="execute_mk_script_start"/>
     <antcall target="execute_mk_script_complete"/>
  </target>

  <target name="execute_mk_script_start" if="stardev.exists">

    <!-- Execute the given action for all known operating system types.
     !   This uses modified mk and makefiles from an old-style system
     !   which should be stored in ${src.jni.dir} along with the source
     !   code. Note some of these OS names seem to change from time to
     !   time and across JVMs, so beware. Clearly this is not portable.
     !-->

    <!-- Copy all source code into the build directory (keeps any
     !   intermediary files out of the source tree) -->
    <copy todir="${build.jni}">
      <fileset dir="${src.jni.dir}" includes="*"/>
    </copy>
    <chmod perm="ugo+rx" dir="${build.jni}" includes="*" maxparallel="50"/>

    <!-- Local and installed versions of any shareable libraries that we
     !   require to resolve against in a form for the UNIX "ld" command
     !-->
    <property name="jniast.share"
              value="-L${star.jar.dir}/${os.arch} -ljniast"/>
    <!-- OSX needs the full path, as JNI uses .jnilib not .dylib so -l fails-->
    <property name="jniast.share.osx"
              value="${star.jar.dir}/${os.arch}/libjniast.jnilib"/>

    <property name="java.shareables" value="${jniast.share}"/>
    <property name="java.shareables.osx" value="${jniast.share.osx}"/>

    <mkdir dir="${build.lib.arch}"/>

    <echo message="java.home=${java.home}"/>

    <!-- Note: these are selected by the "os" argument, which matches
     !   the current JVM value, so only one is actually executed. -->
    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Linux">
      <env key="SYSTEM" value="ix86_Linux"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="linux"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="SunOS">
      <env key="SYSTEM" value="sun4_Solaris"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="${os.arch}"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="OSF1">
      <env key="SYSTEM" value="alpha_OSF1"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="alpha"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

    <exec dir="${build.jni}" executable="${build.jni}/mk" os="Mac OS X">
      <env key="SYSTEM" value="MacOSX"/>
      <env key="STARLINK" value="${stardev}"/>
      <env key="JAVA_SYSTEM" value="${os.arch}"/>
      <env key="JAVA_HOME" value="${java.home}/.."/>
      <env key="JAVA_SHAREABLES" value="${java.shareables.osx}"/>
      <env key="TARGET_LIB" value="${build.lib.arch}"/>
      <env key="STARJAVA_LIB" value="${star.install}/lib/${os.arch}"/>
      <arg line="${mk.action}"/>
    </exec>

  </target>

  <!-- Inverse of above, use to report that execute_mk_script_real has not
       been invoked, as stardev.exists is not set-->
  <target name="execute_mk_script_complete" unless="stardev.exists">
     <echo>
JNI libraries not built (NDF library not installed in ${stardev})"
     </echo>
  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of sub-components are also required these should be also
   !  created here. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs) on and, if
   !  appropriate, defines the application entrance point. The jar
   !  files should be placed directly in the distribution directories.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${dist.lib.pkg}"/>
    <jar destfile="${dist.lib.pkg}/${name}.jar"
         basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Main-Class"
                   value="uk.ac.starlink.splat.SplatMain"/>
        <attribute name="Class-Path" value="${jar.class.path}"/>
      </manifest>
    </jar>

    <!-- Architecture dependent jar files (shareable libraries for
     !   webstart) -->
    <copy todir="${dist.lib}">
       <fileset dir="${src.jars.dir}" includes="**/*.jar **/*.zip"/>
    </copy>

    <jar destfile="${dist.lib.pkg}/${name}_examples.jar"
         basedir="${build.examples}"/>

    <!-- Sign all jar files -->
    <antcall target="signjar"/>

  </target>

  <!-- Local target so it can be skipped when "skip.sign.jar" is set -->
  <target name="signjar"
          description="sign all jar files"
          unless="sign.jar.skip">

    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib}" includes="**/*.jar **/*.zip"/>
    </signjar>

  </target>


  <!--
   !   ========================================
   !   Make package JNLP file for Java webstart
   !   ========================================
   !-->
  <target name="webstart"
          description="-> create webstart descriptor files">

    <!-- Create a webstart JNLP file for this package, this goes into
     !   "dist.lib" -->
    <mkdir dir="${dist.lib}"/>
    <jnlp toFile="${dist.lib}/${name}.jnlp" href="${name}.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>Starlink SPLAT-VO - A Spectral Analysis Tool</title>
         <vendor>Starlink Support Community/GAVO</vendor>
         <homepage href="${home.page}"/>
         <icon kind="splash" href="${webstart.splashicon}"/>
         <icon kind="shortcut" href="${webstart.shortcuticon}"/>
         <icon href="${webstart.shortcuticon}"/>
         <description>Starlink SPLAT-VO - Webstart edition</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <jar href="splat/splat.jar" main="true"/>
         <extension name="SPLAT-PARTS" href="splat-parts.jnlp"/>
         <extension name="JSKY-PARTS" href="jsky-parts.jnlp"/>
       </resources>
       <application_desc main_class="uk.ac.starlink.splat.SplatMain"/>
     </jnlp>

     <!-- May be needed as a component so provide that too -->
     <jnlp toFile="${dist.lib}/${name}-parts.jnlp" href="${name}-parts.jnlp"
          codebase="${webstart.codebase}">
      <information>
         <title>Starlink SPLAT-VO - A Spectral Analysis Tool</title>
         <vendor>Starlink Support Community/GAVO</vendor>
         <homepage href="${home.page}"/>
         <icon kind="splash" href="${webstart.splashicon}"/>
         <icon href="${webstart.starlink_logo}"/>
         <description>"Starlink SPLAT-VO - Webstart edition"</description>
         <offline_allowed/>
       </information>
       <security>
          <all_permissions/>
       </security>
       <resources>
         <j2se version="1.5+"/>
         <fileset dir="${dist.lib}" includes="splat/*.jar splat/*.zip"/>
         <extension name="DATANODE" href="datanode.jnlp"/>
         <extension name="ASTGUI" href="astgui.jnlp"/>
         <extension name="NDX" href="ndx.jnlp"/>
         <extension name="JNIAST" href="jniast.jnlp"/>
         <extension name="SOAPSERVER" href="soapserver.jnlp"/>
         <extension name="FITS" href="fits.jnlp"/>
         <extension name="HDS" href="hds.jnlp"/>
         <extension name="PAL" href="pal.jnlp"/>
         <extension name="DIVA" href="diva.jnlp"/>
         <extension name="HELP" href="help.jnlp"/>
         <extension name="TABLE" href="table.jnlp"/>
         <extension name="VO" href="vo.jnlp"/>
         <extension name="JSAMP" href="jsamp.jnlp"/>
       </resources>

       <!-- Do not enable this until webstart supports the loading
            of dependent libraries (JNIAST). 23/11/06 they are no
            workarounds (I've tried them all), so don't waste time
            on this. The bug to be fixed is:

            http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4491398
       -->

       <!-- Linux >
       <resources os="Linux" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Linux" arch="amd64">
         <nativelib href="amd64/${name}_libs.jar"/>
       </resources-->

       <!-- IBM Linux >
       <resources os="Linux" arch="x86">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources-->

       <!-- Windows >
       <resources os="Windows">
          <nativelib href="x86/${name}_libs.jar"/>
       </resources-->

       <!-- Mac OS X >
       <resources os="Mac OS X" arch="i386">
         <nativelib href="i386/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="x86_64">
         <nativelib href="x86_64/${name}_libs.jar"/>
       </resources>
       <resources os="Mac OS X" arch="ppc64">
         <nativelib href="ppc64/${name}_libs.jar"/>
       </resources-->

       <component_desc/>
     </jnlp>

  </target>

  <!--
   !   =================================
   !   Configures the local distribution
   !   =================================
   !
   !  Completes the creation of the local distribution into the
   !  directory "dist.dir" (usually the current directory).
   !  Installations and exports are based on the state of this
   !  distribution, so it must be performed before installation or
   !  export. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have
   !  source). Much of the work of getting the distribution
   !  directories into the correct state is performed by the dependency
   !  targets.
   !-->
  <target name="dist"
          depends="build,jars,javadocs,webstart"
          unless="runonly.install"
          description="-> configures the local binary distribution">

    <!-- Make sure all the distribution directories exist -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.bin.pkg}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.lib.arch}"/>
    <mkdir dir="${dist.docs.pkg}"/>
    <mkdir dir="${dist.etc.pkg}"/>

    <!-- Copy any startup scripts etc. -->
    <copy todir="${dist.bin.pkg}">
      <fileset dir="${script.dir}">
        <include name="*"/>
        <include name=".splat_autoloads"/>
        <and>
          <type type="file"/>
        </and>
      </fileset>
    </copy>

    <!-- Copy auxiliary files. -->
    <copy todir="${dist.etc.pkg}">
      <fileset dir="${src.etc}"/>
    </copy>

    <!-- Copy extra documentation, note doesn't include javadocs these
     !   are generated from the source-->
    <copy todir="${dist.docs.pkg}">
      <fileset dir="${src.docs}"/>
    </copy>

    <!-- Unpack the SPLAT SUN in hypertext format ${dist.docs} level to be
     !   picked up by findme/showme. -->
    <untar src="${src.docs}/sun243.htx_tar.gz" dest="${dist.docs}"
           compression="gzip" overwrite="true"/>

    <!-- Set permissions on contents of distribution directories -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}" maxparallel="50"/>
    <chmod perm="ugo+x" type="file" failonerror="${chmod.fail}"
           maxparallel="50">
       <fileset dir="${dist.bin}"/>
    </chmod>
    <chmod perm="ugo+rx" dir="${dist.lib}" type="file" includes="libsplat*"
           failonerror="${chmod.fail}" maxparallel="50"/>
  </target>


  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

     <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall>

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

     <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>
      <zipfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>

        <!-- Exclude local development support from distribution-->
        <exclude name="local/**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <tar longfile="gnu" destfile="${archive.name}.tar">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.bin}" prefix="${name}/bin">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>
      <tarfileset dir="${dist.etc}" prefix="${name}/etc">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
        <exclude name="local/**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${archive.name}.tar.gz"
          src="${archive.name}.tar"/>
    <bzip2 zipfile="${star.archive.dir}/${archive.name}.tar.bz2"
           src="${archive.name}.tar"/>
    <delete file="${archive.name}.tar"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <property name="star.lib.arch" value="${star.lib}/${os.arch}"/>

    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.bin.pkg}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.etc.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>
    <mkdir dir="${star.lib.arch}"/>

    <loggedcopy todir="${star.bin}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.bin}"/>
    </loggedcopy>

    <!-- Also remove the package-specific directory.
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.bin.pkg}
</echo>

    <chmod perm="ugo+rx" failonerror="${chmod.fail}">
      <fileset dir="${star.bin}">
        <present targetdir="${dist.bin}" present="both"/>
      </fileset>
    </chmod>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.lib}">
        <include name="**/*.jnlp"/>
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/libsplat.*"/>
      </fileset>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}" filtering="true"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>

    <loggedcopy todir="${star.etc}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.etc}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.etc.pkg}
</echo>

  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   ========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

     <!-- Make sure that the expected file structure exists, some
          of these files can be missing if originally empty -->
     <mkdir dir="${dist.dir}"/>
     <mkdir dir="${dist.bin.pkg}"/>
     <mkdir dir="${dist.lib.pkg}"/>
     <mkdir dir="${dist.lib.arch}"/>
     <mkdir dir="${dist.docs.pkg}"/>
     <mkdir dir="${dist.etc.pkg}"/>

     <!-- Do normal install, but with many targets switched off-->
     <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   !  Uses the content of the "${install.log}" to remove the files
   !  that were copied into place by the install target. If this fails
   !  then hopefully the log file will not be deleted!
   !-->
 <target name="deinstall"
          description="-> undo the install target">

    <available file="${install.log}" property="install.log.present"/>

    <antcall target="real_deinstall"/>

  </target>

  <!-- Real deinstall target. Only activated if "install.log.present"
   !   is defined -->
  <target name="real_deinstall"
          if="install.log.present">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}"/>

  </target>

  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${dist.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${dist.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             source="${source.version}"
             classpathref="classpath">

      <doclet name="com.sun.tools.doclets.standard.Standard">
        <param name="-breakiterator"/>
      </doclet>

      <!-- Get a list of directories that name all the potential
       !   java packages -->
      <packageset dir="${java.dir}" defaultexcludes="yes">
         <include name="**"/>
         <exclude name="**/retired_code"/>
         <exclude name="**/*Test*"/>
      </packageset>

      <!-- Link to the full Java API at SUNs website -->
      <link offline="true" href="${javaapi.url}"
            packagelistLoc="${javaapi.lis}"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom><![CDATA[<i>Copyright &#169; ${year} Central Laboratory of the Research Councils. All Rights Reserved.<i>]]></bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">
    <uptodate property="javadoc.notrequired"
              targetfile="${dist.javadocs}/packages.html" >
        <srcfiles dir= "${java.dir}" includes="**/*.java"/>
    </uptodate>
  </target>

  <!--
   !   ==========================================
   !   Creates the API documentation java sources
   !   ==========================================
   !
   !  Just copies the sources into the correct place.
   !-->
    <target name="javadoc-sources"
          description="-> make source files for release API documentation">
     <mkdir dir="${build.java}"/>

    <!-- Copy and/or generate the source to be included when creating
     !   the full Starlink API javadocs-->

    <copy todir="${build.java}">
      <fileset dir="${java.dir}" defaultexcludes="yes">
        <include name="**/*.java"/>
        <exclude name="**/retired_code/*"/>
        <exclude name="**/*Test*"/>
        <exclude name="**/ExtractNDFWCS2XML.java"/>
        <exclude name="**/FITS.java"/>
        <exclude name="**/*Holder.java"/>
      </fileset>
    </copy>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   ! Note these are not JUnit based
   !-->
  <target name="compile-tests"
          depends="build"
          if="junit.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests">
  </target>

  <target name="run-tests"
          depends="compile-tests"
          if="junit.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}"
           forkmode="once">

      <classpath refid="tests-classpath"/>

      <!-- Need to pick up local JNIAST, which might be installed or on the
       !   library path, note that java.library.path cannot be changed inside
       !   a JVM, so we have to fork and pass this from the environment.
       !   Set LD_LIBRARY_PATH and DYLD_LIBRARY_PATH as they are the only two
       !   ways that we support and are required for this to work (think
       !   this is because libsplat.so depends on libjniast.so and the JVM
       !   doesn't handle the loading of additional references). -->
      <!--sysproperty key="java.library.path" value="${jni-ldpath}"/-->
      <env key="LD_LIBRARY_PATH" value="${jni-ldpath}"/>
      <env key="DYLD_LIBRARY_PATH" value="{$jni-ldpath}"/>

      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <sysproperty key="java.awt.headless" value="${java.awt.headless}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
        </fileset>
      </batchtest>

    </junit>

  </target>

  <!-- Compile all code and run up the UI -->
  <target name="fullui"
          depends="compile-tests">
    <antcall target="debugui"/>
  </target>

  <!-- RUN up UI without compilation dependency (for testing/inspecting
   !   when coding not complete). -->
  <target name="debugui">

    <!-- Run up SPLAT from the local build, enable for remote JPDA debugging-->
    <java classname="uk.ac.starlink.splat.SplatMain" fork="true">
      <classpath refid="tests-classpath"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <jvmarg value="-mx1024m"/>
      <jvmarg value="-Xdebug"/>
      <jvmarg value="-Xnoagent"/>
      <!--jvmarg value="-Xrunhprof:cpu=samples,file=profile.log"/-->
      <jvmarg value="-Djava.compiler=NONE"/>
      <jvmarg value="-Dsplat.development=${splat.development}"/>
      <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7000"/>
      <jvmarg value="-Dsplat.etc=${src.etc}"/>
      <arg value="src/etc/testdata/NGC1275.txt"/>
    </java>
  </target>

  <!-- RUN up UI without compilation dependency and without remote
   !   debugging support -->
  <target name="plainui">

    <java classname="uk.ac.starlink.splat.SplatMain" fork="true">
      <classpath refid="tests-classpath"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <jvmarg value="-Dsplat.development=${splat.development}"/>
      <jvmarg value="-Daxis.EngineConfigFactory=uk.ac.starlink.soap.AppEngineConfigurationFactory"/>
      <jvmarg value="-Daxis.ServerFactory=uk.ac.starlink.soap.AppAxisServerFactory"/>
      <arg value="src/etc/testdata/ramp.txt"/>
    </java>
  </target>

  <!-- Execute a given class with up to two arguments -->
  <property name="runclass" value="uk.ac.starlink.splat.SplatMain"/>
  <property name="runclass.args1" value=""/>
  <property name="runclass.args2" value=""/>
  <target name="runclass"
          depends="compile-tests">

    <java classname="${runclass}" fork="true">
      <classpath refid="tests-classpath"/>
      <sysproperty key="http.proxyHost" value="${http.proxyHost}"/>
      <sysproperty key="http.proxyPort" value="${http.proxyPort}"/>
      <arg value="${runclass.args1}"/>
      <arg value="${runclass.args2}"/>
    </java>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>


  <!--
   !   ==========================
   !   Build standalone jar files
   !   ==========================
   !
   !  Builds jar files which can be used on their own, without needing any
   !  other jars to be present, however, SPLAT will not work in this mode and
   !  requires the shareable libraries of JNIAST and JNIHDS.
   !-->
  <target name="build-standalone"
          description="-> builds a standalone jar file">

    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>

    <java classname="uk.ac.starlink.util.SuperJar" failonerror="yes">
      <classpath refid="classpath"/>
      <arg value="-o"/><arg value="${dist.lib.pkg}/splat-full.jar"/>
      <arg value="-x"/><arg value="srb.jar"/>
      <arg value="${star.lib.pkg}/splat.jar"/>
    </java>
    <jar destfile="${dist.lib.pkg}/splat-full.jar"
         update="yes"
         basedir="${star.bin}"
         includes="splat"/>

    <signjar alias="${webstart.alias}"
             keystore="${webstart.keystore}"
             keypass="${webstart.keypass}"
             storepass="${webstart.storepass}">
      <fileset dir="${dist.lib.pkg}"
               includes="splat-full.jar"/>
    </signjar>
  </target>

</project>
