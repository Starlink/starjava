/*
 * Copyright (C) 2003 Central Laboratory of the Research Councils
 *
 *  History:
 *     28-SEP-2000 (Peter W. Draper):
 *       Original version.
 */
package uk.ac.starlink.splat.data;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import nom.tam.fits.BasicHDU;
import nom.tam.fits.BinaryTable;
import nom.tam.fits.BinaryTableHDU;
import nom.tam.fits.Fits;
import nom.tam.fits.HeaderCard;
import nom.tam.util.BufferedDataOutputStream;
import nom.tam.util.Cursor;

import uk.ac.starlink.splat.iface.GlobalSpecPlotList;
import uk.ac.starlink.splat.iface.SpectrumIO;
import uk.ac.starlink.splat.iface.SplatBrowser;
import uk.ac.starlink.splat.iface.SpectrumIO.SourceType;
import uk.ac.starlink.splat.util.SplatException;
import uk.ac.starlink.splat.util.Utilities;


/**
 * SpecList is a singleton object that contains references to all the
 * known spectra. The SpecList object should be updated with any new spectra
 * when they are created and also updated whenever a spectrum is
 * destroyed. Normally this task will be performed using the 
 * {@link GlobalSpecPlotList} object.
 *
 * @version $Id$
 * @author Peter W. Draper
 *
 * @see SpecDataFactory
 * @see "The Singleton Design Pattern"
 *
 */
public class SpecList implements Serializable
{
    
    /**
     * File format enumeration for saving the spectra list
     */
    public static enum FileFormat{
        
        STK("stk", "STK files", 0),
        FITS("fits", "FITS files", 1);
        
        private String fileExtension;
        private String description;
        private int listIndex;
        
        private FileFormat(String fileExtension, String description, int listIndex) {
            this.fileExtension = fileExtension;
            this.description = description;
            this.listIndex = listIndex;
        }

        public String getFileExtension() {
            return fileExtension;
        }
        
        public String getDescription() {
            return description;
        }
        
        public int getListIndex() {
            return listIndex;
        }
        
        public FileFormat getByExtension(String extension) {
            if (extension != null) {
                for (FileFormat ff : FileFormat.values()) {
                    if (extension.equalsIgnoreCase(ff.getFileExtension()))
                        return ff;
                }
            }
            return null;
        }
    }
    
    /**
     *  Create the single class instance.
     */
    private static final SpecList instance = new SpecList();

    /**
     *  Hide the constructor from use.
     */
    private SpecList() {}

    /**
     *  Return reference to the only allowed instance of this class.
     */
    public static SpecList getInstance()
    {
        return instance;
    }

    /**
     *  ArrayList of references to spectra
     */
    protected ArrayList spectra = new ArrayList();
    
    
    /**
     * Map of spectra and the source, from which the spectra came from
     */
    protected Map<SpecData, SourceType> sources = new HashMap<SpecData, SourceType>();


    /**
     *  Serialization version ID string (generated by serialver on
     *  original star.jspec.data.SpecList class).
     */
    static final long serialVersionUID = 6942346493134803694L;

    /**
     *  Get the number of spectra.
     */
    public int specCount()
    {
        return spectra.size();
    }

    /**
     *  Add a spectrum.
     */
    public int add( SpecData spectrum, SourceType sourceType )
    {
        spectra.add( spectrum );
        sources.put(spectrum, sourceType);
        return spectra.size() - 1;
    }
    
    /**
     *  Add a spectrum with unknown source type.
     */
    public int add(SpecData spectrum) {
        return add(spectrum, SourceType.UNDEFINED);
    }

    /**
     *  Add or replace a spectrum.
     */
    public int add( int index, SpecData spectrum, SourceType sourceType )
    {
        if ( index < specCount() ) {
            spectra.set( index, spectrum );
            return index;
        } 
        else {
            return add( spectrum, sourceType );
        }
    }
    
    /**
     *  Add a spectrum with an unknown source or replace a spectrum.
     */
    public int add( int index, SpecData spectrum )
    {
        return add( index, spectrum, SourceType.UNDEFINED );
    }

    /**
     *  Remove a spectrum.
     */
    public int remove( SpecData spectrum )
    {
        int index = spectra.indexOf( spectrum );
        if ( index != -1 ) {
            if (sources.containsKey(spectrum))
                sources.remove(spectrum);
            
            spectra.remove( index );        
        }
        return index;
    }

    /**
     *  Remove a spectrum.
     */
    public void remove( int index )
    {
        if ( index < specCount() ) {
            SpecData spectrum = (SpecData) spectra.get(index);
            if (sources.containsKey(spectrum))
                sources.remove(spectrum);
            
            spectra.remove( index );
        }
    }

    /**
     *  Get a spectrum by index.
     */
    public SpecData get( int index )
    {
        if ( index < specCount() ) {
            return (SpecData)spectra.get( index );
        }
        return null;
    }

    /**
     *  Get the index of a spectrum.
     */
    public int indexOf( SpecData spectrum )
    {
        return spectra.indexOf( spectrum );
    }

    /**
     *  Return the index of a spectrum with the given short
     *  name. Returns -1 if unsuccessful.
     */
    public int indexOf( String shortName )
    {
        for ( int i = 0; i < spectra.size(); i++ ) {
            if ( getShortName( i ).equals( shortName ) ) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 
     * @param spectrum
     * @return source type from which the spectra came from
     */
    public SourceType getSourceType(SpecData spectrum) {
        return sources.get(spectrum);
    }
    
    /**
     *  Return the full (i.e.<!-- --> disk file) name of a spectrum.
     */
    public String getFullName( int index )
    {
        if ( index < specCount() ) {
            return ((SpecData)spectra.get( index )).getFullName();
        }
        return null;
    }

    /**
     *  Return the symbolic name of a spectrum.
     */
    public String getShortName( int index )
    {
        if ( index < specCount() ) {
            return ((SpecData)spectra.get( index )).getShortName();
        }
        return null;
    }

    /**
     *  Set the symbolic name of a spectrum.
     */
    public void setShortName( int index, String name )
    {
        if ( index < specCount() ) {
            ((SpecData)spectra.get( index )).setShortName( name );
        }
    }

    /**
     *  Set the name of a spectrum.
     */
    public void setShortName( SpecData spectrum, String name )
    {
        spectrum.setShortName( name );
    }

    /**
     *  See if a spectrum is already present using its specification
     * (i.e.<!-- --> file name). Returns the index if found and -1 otherwise.
     */
    public int known( String fileName )
    {
        for ( int i = 0; i < spectra.size(); i++ ) {
            if ( ((SpecData)spectra.get(i)).getFullName().equals(fileName) ) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Save current state to a file as a serialised stream. The stream
     * is Gzipped to save space and should be restored using the
     * readStack method (which appends the previous state).
     */
    public void writeStack( String fileName ) {
        writeStack(SpecList.FileFormat.STK, fileName);
    }
    
    /**
     * Save current state to a file as a serialised stream. The stream
     * is Gzipped to save space and should be restored using the
     * readStack method (which appends the previous state).
     * 
     * @param fileFormat Format of the result file
     */
    public void writeStack( SpecList.FileFormat fileFormat, String fileName )
    {
        
        // TODO make it protected somewhere else...
        SpecDataFactory specDataFactory = SpecDataFactory.getInstance();
        //int saveUsertypeIndex = SpecDataFactory.DEFAULT;
        
        switch (fileFormat) {
            case FITS:
                try {
                    OutputStream file = new FileOutputStream( fileName );
                    OutputStream buffer = new GZIPOutputStream( file );
                    ObjectOutputStream out = new ObjectOutputStream( buffer );
                    out.writeObject( this );
                    out.close();
                    
                    Fits fitsref = new Fits();
                    
                    for (int i = 0; i < spectra.size(); i++) {
                        synchronized(spectra.get(i)) {
                            SpecData target =
                                    specDataFactory.getClone( (SpecData)spectra.get(i), "", SpecDataFactory.FITS,
                                       "fits" );
                            BasicHDU extHdu = ((FITSSpecDataImpl)(target.getSpecDataImpl())).makeHDU(false);
                            
                            Cursor iter = extHdu.getHeader().iterator();
                            iter.setKey( "OBJECT" );
                            if ( iter.hasNext() ) {
                                iter.next();
                            }
                            
                            /*iter.add( "GNRTR", new HeaderCard( "GNRTR", Utilities.getReleaseName(),
                                    "SPLAT's list of spectra item" ) );
                            
                            iter.add( "GNRTRVER", new HeaderCard( "GNRTRVER", Utilities.getReleaseVersion(),
                                    "" ) );*/
                            
                            iter.add( "EXTNAME", new HeaderCard( "EXTNAME", "SPECTRUM",
                                "" ) );
                            
                            fitsref.addHDU(extHdu);
                        }
                    }
                    
                    OutputStream fo = new FileOutputStream( fileName );
                    BufferedDataOutputStream os = new BufferedDataOutputStream( fo );
                    fitsref.write( os );
                } 
                catch (Exception ex) {
                    ex.printStackTrace();
                }
                break;
            case STK:
                try {
                    OutputStream file = new FileOutputStream( fileName );
                    OutputStream buffer = new GZIPOutputStream( file );
                    ObjectOutputStream out = new ObjectOutputStream( buffer );
                    out.writeObject( this );
                    out.close();
                } 
                catch (Exception ex) {
                    ex.printStackTrace();
                }
                break;
        }
    }

    /**
     * Read a previous list of spectra stored as a serialised Gzipped
     * stream in a disk file (by the writeStack method). All recovered
     * spectra are append and converted in memory resident objects
     * (rather than retaining their associated with a disk file,
     * i.e. NDF, TEXT or FITS spectra).
     *
     * @param fileName name of the file containing the serialised data.
     * @return the number of spectra that are restored.
     */
    public int readStack( String fileName )
    {
        return readStack(fileName, FileFormat.STK, null);
     }
     
     /**
      * Read a previous list of spectra stored as a serialised Gzipped
      * stream in a disk file (by the writeStack method). All recovered
      * spectra are append and converted in memory resident objects
      * (rather than retaining their associated with a disk file,
      * i.e. NDF, TEXT or FITS spectra).
      *
      * @param fileName name of the file containing the data.
      * @param fileFormat format of the file - STK/FITS/...
      * @return the number of spectra that are restored.
      */
     public int readStack( String fileName, FileFormat fileFormat, SplatBrowser splatBrowser )
     {
        int restored = 0;
        
        switch (fileFormat) {
            case STK:
                try {
                    InputStream file = new FileInputStream( fileName );
                    restored = readStack( file );
                    file.close();
                } 
                catch (Exception e) {
                    e.printStackTrace();
                }
                break;
            case FITS:
                if (fileName != null) {
                    try {
                        List<SpecData> spectra = SpecDataFactory.getInstance().getAll(fileName);
                        for (SpecData spectrum : spectra) {
                            splatBrowser.addSpectrum(spectrum);
                        }
                        restored = spectra.size();
                    } catch (SplatException e) {
                        e.printStackTrace();
                    }
                }
                break;
            }
        return restored;
    }

    /**
     * Read a previous list of spectra stored as a serialised Gzipped
     * stream (must originate from the writeStack method). All recovered
     * spectra are append and converted in memory resident objects
     * (rather than retaining their associated with a disk file,
     * i.e. NDF, TEXT or FITS spectra).
     *
     * @param in the stream containing the serialised data.
     * @return the number of spectra that are restored.
     */
    public int readStack( InputStream in )
    {
        int restored = 0;
        try {
            InputStream buffer = new GZIPInputStream( in );
            ObjectInputStream oin = new ObjectInputStream( buffer );
            SpecList specList = (SpecList) oin.readObject();
            oin.close();
            buffer.close();
            GlobalSpecPlotList gList = GlobalSpecPlotList.getInstance();
            for ( int i = 0; i < specList.specCount(); i++ ) {
                SpecData specData = specList.get( i );
                gList.add( specList.get( i ) ); 
                restored++;
            }
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
        return restored;
    }
}
