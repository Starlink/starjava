<html>
<head>
<title>Axis Reference Guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="axis.css" rel=stylesheet type=text/css>
</head>

<body>
<h1 align="center"><IMG height=96 src="images/axis.jpg" width=176></h1>
<h1>Axis Reference Guide</h1>
<p><i>1.1 Version</i></p>
<h3>Table of Contents</h3>
<ul>
  <li><a href="#Tools">Tools Reference</a></li>
  <ul>
    <li><a href="#WSDL2Java">WSDL2Java</a></li>
    <li><a href="#Java2WSDL">Java2WSDL</a></li>
    <li><a href="#Java2WSDL">Java2WSDL</a></li>
  </ul>
  <li><a href="#Deployment">Deployment (WSDD) Reference</a></li>
  <li><a href="#global_configuration">Global Axis Configuration</a></li>
  <li><a href="#individual_service">Individual Service Configuration</a></li>
  <li><a href="#axis_logging">Axis Logging Configuration</a></li>
  <li><a href="#axis_components" >Pre-Configured Axis Components Reference</a></li>
</ul>
<h2> <a name="Tools"></a>Tools Reference</h2>
<h3><a name="WSDL2Java"></a>WSDL2Java Reference</h3>
<p>Usage:&nbsp; java org.apache.axis.wsdl.WSDL2Java [options] WSDL-URI <br>
  Options: <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -h, --help <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  print this message and exit <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -v, --verbose <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  print informational messages <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -n, --noImports <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  only generate code for the immediate WSDL document <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -O, --timeout &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  timeout in seconds (default is 45, specify -1 to disable) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -D, --Debug <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  print debug information <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -W, --noWrapped<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  turn off support for &quot;wrapped&quot; document/literal<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -s, --server-side <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  emit server-side bindings for web service <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -S, --skeletonDeploy &lt;argument> 
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  deploy skeleton (true) or implementation (false) in deploy.wsdd. <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  Default is false.&nbsp; Assumes --server-side. <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -N, --NStoPkg &lt;argument>=&lt;value> 
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  mapping of namespace to package <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -f, --fileNStoPkg &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  file of NStoPkg mappings (default NStoPkg.properties) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -p, --package &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  override all namespace to package mappings, use this package <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  name instead <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -o, --output &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  output directory for emitted files <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -d, --deployScope &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  add scope to deploy.xml: "Application", "Request", "Session" <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -t, --testCase <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  emit junit testcase class for web service <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -a, --all <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  generate code for all elements, even unreferenced ones <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -T, --typeMappingVersion <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  indicate 1.1 or 1.2.  The default is 1.1 (SOAP 1.1 JAX-RPC compliant.
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    1.2 indicates SOAP 1.1 encoded.) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -F, --factory &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    name of a custom class that implements GeneratorFactory interface
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    (for extending Java generation functions) <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -H, --helperGen <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    emits separate Helper classes for meta data <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -U, --user &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  username to access the WSDL-URI <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -P, --password &lt;argument> <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  password to access the WSDL-URI <br>
  &nbsp; 
<h4> -h, --help</h4>
Print the usage statement and exit 
<h4> -v, --verbose</h4>
See what the tool is generating as it is generating it. 
<h4> -n, --noImports</h4>
Only generate code for the WSDL document that appears on the command line.&nbsp; 
The default behaviour is to generate files for all WSDL documents, the immediate 
one and all imported ones. 
<h4> -O, --timeout</h4>
Timeout in seconds.  The default is 45.  Use -1 to disable the timeout.
<h4> -D, --Debug</h4>
Print debug information, which currently is WSDL2Java's symbol table.  Note that this is only printed after the symbol table is complete, ie., after the WSDL is parsed successfully.
<h4>-W, --noWrapped</h4>
This turns off the special treatment of what is called "wrapped" document/literal
style operations. &nbsp;By default, WSDL2Java will recognize the following
conditions:<br>
<ul>
  <li>If an input message has is a single part.</li>
  <li>The part is an element.</li>
  <li>The element has the same name as the operation</li>
  <li>The element's complex type has no attributes<br>
  </li>
</ul>
When it sees this, WSDL2Java will 'unwrap' the top level element, and treat each 
of the components of the element as arguments to the operation. This type of WSDL 
is the default for Microsoft .NET web services, which wrap up RPC style arguments 
in this top level schema element.
<h4> -s, --server-side</h4>
Emit the server-side bindings for the web service: 
<ul>
  <li> a skeleton class named &lt;bindingName>Skeleton.&nbsp; This may or may 
    not be emitted (see -S, --skeletonDeploy).</li>
  <li> an implementation template class named &lt;bindingName>Impl.&nbsp; Note 
    that, if this class already exists, then it is not emitted.</li>
  <li> deploy.wsdd</li>
  <li> undeploy.wsdd</li>
</ul>
<h4> -S, --skeletonDeploy &lt;argument></h4>
Deploy either the skeleton (true) or the implementation (false) in deploy.wsdd.&nbsp; 
In other words, for "true" the service clause in the deploy.wsdd file will look 
something like: 
<pre class="example">&lt;service name="AddressBook" provider="java:RPC">
&nbsp;&nbsp;&nbsp; &lt;parameter name="className" value="samples.addr.AddressBookSOAPBindingSkeleton"/>
&nbsp;&nbsp;&nbsp; ...
&lt;/service></pre>
<p>and for "false" it would look like: 
<pre class="example">&lt;service name="AddressBook" provider="java:RPC">
&nbsp;&nbsp;&nbsp; &lt;parameter name="className" value="samples.addr.AddressBookSOAPBindingImpl"/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&lt;/service></pre>
<p>The default for this option is false.&nbsp; When you use this option, the --server-side 
  option is assumed, so you don't have to explicitly specify --server-side as 
  well. 
<h4> -N, --NStoPkg &lt;argument>=&lt;value></h4>
By default, package names are generated from the namespace strings in the WSDL 
document in a magical manner (typically, if the namespace is of the form "http://x.y.com" 
or "urn:x.y.com" the corresponding package will be "com.y.x").&nbsp; If this magic 
is not what you want, you can provide your own mapping using the --NStoPkg argument, 
which can be repeated as often as necessary, once for each unique namespace mapping.&nbsp; 
For example, if there is a namespace in the WSDL document called "urn:AddressFetcher2", 
and you want files generated from the objects within this namespace to reside 
in the package samples.addr, you would provide the following option to WSDL2Java: 
<pre>--NStoPkg urn:AddressFetcher2=samples.addr</pre>
(Note that if you use the short option tag, "-N", then there must not be a space 
between "-N" and the namespace.) <br>
&nbsp; 
<h4> -f, --fileNStoPkg &lt;argument></h4>
If there are a number of namespaces in the WSDL document, listing a mapping for 
them all could become tedious.&nbsp; To help keep the command line terse, WSDL2Java 
will also look for mappings in a properties file.&nbsp; By default, this file 
is named "NStoPkg.properties" and it must reside in the default package (ie., 
no package).&nbsp; But you can explicitly provide your own file using the --fileNStoPkg 
option. 
<p>The entries in this file are of the same form as the arguments to the --NStoPkg 
  command line option.&nbsp; For example, instead of providing the command line 
  option as above, we could provide the same information in NStoPkg.properties: 
<pre>urn\:AddressFetcher2=samples.addr</pre>
(Note that the colon must be escaped in the properties file.) 
<p>If an entry for a given mapping exists both on the command line and in the 
  properties file, the command line entry takes precedence. 
<h4> -p, --package &lt;argument></h4>
This is a shorthand option to map all namespaces in a WSDL document to the same 
Java package name.&nbsp; This can be useful, but dangerous.&nbsp; You must make 
sure that you understand the effects of doing this.&nbsp; For instance there may 
be multiple types with the same name in different namespaces.&nbsp; It is an error 
to use the --NStoPkg switch and --package at the same time. 
<h4> -o, --output &lt;argument></h4>
The root directory for all emitted files. 
<h4> -d, --deployScope &lt;argument></h4>
Add scope to deploy.wsdd: "Application", "Request", or "Session".&nbsp; If this 
option does not appear, no scope tag appears in deploy.wsdd, which the AXIS runtime 
defaults to "Request". 
<h4> -t, --testCase</h4>
Generate a client-side JUnit test case.&nbsp; This test case can stand on its 
own, but it doesn't really do anything except pass default values (null for objects, 
0 or false for primitive types).&nbsp; Like the generated implementation file, 
the generated test case file could be considered a template that you may fill 
in. 
<h4> -a, --all</h4>
Generate code for all elements, even unreferenced ones.&nbsp; By default, WSDL2Java 
only generates code for those elements in the WSDL file that are referenced. 
<p>A note about what it means to be referenced.&nbsp; We cannot simply say:&nbsp; 
  start with the services, generate all bindings referenced by the service, generated 
  all portTypes referenced by the referenced bindings, etc.&nbsp; What if we're 
  generating code from a WSDL file that only contains portTypes, messages, and 
  types?&nbsp; If WSDL2Java used service as an anchor, and there's no service 
  in the file, then nothing will be generated.&nbsp; So the anchor is the lowest 
  element that exists in the WSDL file in the order: <br>
<ol>
  <li>types 
  <li>portTypes 
  <li>bindings 
  <li>services 
</ol>
<p>For example, if a WSDL file only contained types, then all the listed types 
  would be generated.&nbsp; But if a WSDL file contained types and a portType, 
  then that portType will be generated and only those types that are referenced 
  by that portType.
<p>Note that the anchor is searched for in the WSDL file appearing on the command line, <b>not</b> in imported WSDL files.  This allows one WSDL file to import constructs defined in another WSDL file without the nuisance of having all the imported WSDL file's constructs generated.
<h4> -T, --typeMappingVersion &lt;argument></h4>
Indicate 1.1 or 1.2.&nbsp; The default is 1.2 (SOAP 1.2 JAX-RPC compliant). 
<h4> -F, --factory &lt;argument></h4>
Used to extend the functionality of the WSDL2Java emitter. The argument is the 
name of a class which extends JavaWriterFactory. 
<h4> -H, --helperGen</h4>
Emits separate Helper classes for meta data.
<h4> -U, --user &lt;argument&gt;</h4>
This username is used in resolving the WSDL-URI provided as the input to WSDL2Java. 
&nbsp;If the URI contains a username, this will override the command line switch. 
&nbsp;An example of a URL with a username and password is: <code>http://user:password@hostname:port/path/to/service?WSDL</code><br>
<h4> -P, --password &lt;argument&gt;</h4>
This password is used in resolving the WSDL-URI provided as the input to WSDL2Java. 
&nbsp;If the URI contains a password, this will override the command line switch.&nbsp; 
<br>

<h3><a name="Java2WSDL"></a>Java2WSDL Reference</h3>
<p>Here is the help message generated from the current tool: </p>
<p><font color="#993366">
<pre>
Java2WSDL emitter
Usage: java org.apache.axis.wsdl.Java2WSDL [options] class-of-portType
Options:
        -h, --help
                print this message and exit
        -I, --input <argument>
                input WSDL filename
        -o, --output <argument>
                output WSDL filename
        -l, --location <argument>
                service location url
        -P, --portTypeName <argument>
                portType name (obtained from class-of-portType if not specified)
        -b, --bindingName <argument>
                binding name (--servicePortName value + "SOAPBinding" if not specified)
        -S, --serviceElementName <argument>
                service element name (defaults to --servicePortName value + "Service")
        -s, --servicePortName <argument>
                service port name (obtained from --location if not specified)
        -n, --namespace <argument>
                target namespace
        -p, --PkgtoNS <argument>=<value>
                package=namespace, name value pairs
        -m, --methods <argument>
                space or comma separated list of methods to export
        -a, --all
                look for allowed methods in inherited class
        -w, --outputWsdlMode <argument>
                output WSDL mode: All, Interface, Implementation
        -L, --locationImport <argument>
                location of interface wsdl
        -N, --namespaceImpl <argument>
                target namespace for implementation wsdl
        -O, --outputImpl <argument>
                output Implementation WSDL filename, setting this causes --outputWsdlMode to be ignored
        -i, --implClass <argument>
                optional class that contains implementation of methods in class-of-portType.  
				The debug information in the class is used
                to obtain the method parameter names, which are used to set
                the WSDL part names.
        -x, --exclude <argument>
                space or comma separated list of methods not to export
        -c, --stopClasses <argument>
                space or comma separated list of class names which will stop
                inheritance search if --all switch is given
        -T, --typeMappingVersion <argument>
                indicate 1.1 or 1.2.  The default is 1.1 (SOAP 1.1 JAX-RPC 
				 compliant  1.2 indicates SOAP 1.1 encoded.)
        -A, --soapAction <argument>
                value of the operations soapAction field. Values are DEFAULT,
                OPERATION or NONE. OPERATION forces soapAction to the name
                of the operation.  DEFAULT causes the soapAction to be set
                according to the operations meta data (usually "").  NONE forces
				the soapAction to "".  The default is DEFAULT.
        -y, --style <argument>
                The style of binding in the WSDL, either DOCUMENT, RPC, or WRAPPED.
        -u, --use <argument>
                The use of items in the binding, either LITERAL or ENCODED
        -e, --extraClasses <argument>
                A space or comma separated list of class names to be added tO
                The type section.
Details:
   portType element name= <--portTypeName value> OR <class-of-portType name>
   binding  element name= <--bindingName value> OR <--servicePortName value>Soap
Binding
   service  element name= <--serviceElementName value> OR <--portTypeName value>
Service
   port     element name= <--servicePortName value>
   address location     = <--location value>
</pre>
</font>
<br>
 
<p><b>-h , --help</b> <br>
  Prints the help message. 
<p><b>-I, --input &lt;WSDL file></b> <br>
  Optional parameter that indicates the name of the input wsdl file.  The output
  wsdl file will contain everything from the input wsdl file plus the new constructs.
  If a new construct is already present in the input wsdl file, it is not added.
  This option is useful for constructing a wsdl file with multiple ports, bindings,
  or portTypes.
<p><b>-o, --output &lt;WSDL file></b> <br>
  Indicates the name of the output WSDL file.&nbsp; If not specified, a suitable 
  default WSDL file is written into the current directory. 
<p><b>-l, --location &lt;location></b> <br>
  Indicates the url of the location of the service.&nbsp; The name after the last 
  slash or backslash is the name of the service port (unless overridden by the 
  -s option).&nbsp; The service port address location attribute is assigned the 
  specified value. 
<p><b>-P, --portTypeName &lt;name></b> <br>
  Indicates the name to use use for the portType element. If not specified, the 
  class-of-portType name is used. 
<p><b>-b, --bindingName &lt;name></b> <br>
  Indicates the name to use use for the binding element. If not specified, the 
  value of the --servicePortName + "SoapBinding" is used. 
<p><b>-S, --serviceElementName &lt;name></b> <br>
  Indicates the name of the service element.&nbsp; If not specified, the service 
  element is the &lt;portTypeName>Service.&nbsp; 
<p><b>-s, --servicePortName &lt;name></b> <br>
  Indicates the name of the service port.&nbsp; If not specified, the service 
  port name is derived from the --location value.&nbsp; 
<p><b>-n, --namespace &lt;target namespace></b> <br>
  Indicates the name of the target namespace of the WSDL. 
<p><b>-p, --PkgToNS &lt;package> &lt;namespace></b> <br>
  Indicates the mapping of a package to a namespace.&nbsp; If a package is encountered 
  that does not have a namespace, the Java2WSDL emitter will generate a suitable 
  namespace name.&nbsp; This option may be specified multiple times. 
<p><b>-m, --methods &lt;arguments></b> <br>
  If this option is specified, only the indicated methods in your interface class 
  will be exported into the WSDL file.&nbsp; The methods list must be comma separated.&nbsp; 
  If not specified, all methods declared in the interface class will be exported 
  into the WSDL file. 
<p><b>-a, --all</b> <br>
  If this option is specified, the Java2WSDL parser will look into extended classes 
  to determine the list of methods to export into the WSDL file. 
<p><b>-w, --outputWSDLMode &lt;mode></b> <br>
  Indicates the kind of WSDL to generate.&nbsp; Accepted values are: 
<ul>
  <li> All --- (default) Generates wsld containing both interface and implementation 
    WSDL constructs.</li>
  <li> Interface --- Generates a WSDL containing the interface constructs (no 
    service element).</li>
  <li> Implementation -- Generates a WSDL containing the implementation.&nbsp; 
    The interface WSDL is imported via the -L option.</li>
</ul>
<b>-L, --locationImport &lt;url></b> <br>
Used to indicate the location of the interface WSDL when generating an implementation 
WSDL. 
<p><b>-N, --namespaceImpl &lt;namespace></b> <br>
  Namespace of the implementation WSDL. 
<p><b>-O, --outputImpl &lt;WSDL file></b> <br>
  Use this option to indicate the name of the output implementation WSDL file.&nbsp; 
  If specified, Java2WSDL will produce interface and implementation WSDL files.&nbsp; 
  If this option is used, the -w option is ignored. 
<p><b>-i, --implClass &lt;impl-class></b> <br>
  Sometimes extra information is available in the implementation class file. Use 
  this option to specify the implementation class. 
<p><b>-x, --exclude &lt;list></b> <br>
  List of methods to not exclude from the wsdl file. 
<p><b>-c, --stopClasses &lt;list></b> <br>
  List of classes which stop the Java2WSDL inheritance search. 
<p><b>-T, --typeMappingVersion &lt;version></b> <br>
  Choose the default type mapping registry to use. Either 1.1 or 1.2.</p>
<p><b>-A, --soapAction &lt;argument></b> <br>
  The value of the operations soapAction field. Values are DEFAULT, OPERATION or NONE. OPERATION forces soapAction to the name of the operation.  DEFAULT causes the soapAction to be set according to the operation's meta data (usually "").  NONE forces the soapAction to "".  The default is DEFAULT.
<p><b>-y, --style &lt;argument></b> <br>
  The style of the WSDL document: RPC, DOCUMENT or WRAPPED. The default is RPC.
  If RPC is specified, an rpc wsdl is generated. 
  If DOCUMENT is specified, a document wsdl is generated. 
  If WRAPPED is specified, a document/literal wsdl is generated using the wrapped approach.  
  Wrapped style forces the use attribute to be literal.
<p><b>-u, --use &lt;argument&gt;</b><br>
  The use of the WSDL document: LITERAL or ENCODED. If LITERAL is specified, the 
  XML Schema defines the representation of the XML for the request. If ENCODED 
  is specified, SOAP encoding is specified in the generated WSDL. 
<p><b>-e, --extraClasses &lt;argument&gt;</b><br>
  Specify a space or comma seperated list of class names which should be included in the <b>types</b>
  section of the WSDL document.  This is useful in the case where your service interface references
  a base class and you would like your WSDL to contain XML Schema type defintions for these other
  classes.  The -extraClasses option can be specified duplicate times.  
  Each specification results in the additional classes being added to the list.


<h2><a name="Deployment"></a>Deployment (WSDD) Reference</h2>
Note : all the elements referred to in this section are in the WSDD namespace, 
namely &quot;http://xml.apache.org/axis/wsdd/&quot;. 
<dl> 
  <dt><b><font face="Courier New, Courier, mono">&lt;deployment&gt;</font></b></dt>
  <dd>The root element of the deployment document which tells the Axis engine 
    that this is a deployment. A deployment document may represent EITHER a complete 
    engine configuration OR a set of components to deploy into an active engine.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;undeployment&gt;</font></b></dt>
  <dd>The root element of the deployment document which tells Axis that this is 
    an undeployment. Undeployments are only useful as </dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;handler [name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot;] 
    type=&quot;</font></b><font face="Courier New, Courier, mono"><i>type</i></font><b><font face="Courier New, Courier, mono">&quot;/&gt;</font></b></dt>
  <dd>Belongs at the top level inside a <b>&lt;deployment&gt;</b> or <b>&lt;undeployment&gt;</b>, 
    or inside a <b>&lt;chain&gt;</b>, <b>&lt;requestFlow&gt;</b>, or <b>&lt;responseFlow&gt;</b>. 
    Defines a Handler, and indicates the type of the handler. &quot;Type&quot; 
    is either the name of another previously defined Handler, or a QName of the 
    form &quot;<b>java:<i>class.name</i></b>&quot;. The optional &quot;name&quot; 
    attribute allows you to refer to this Handler definition in other parts of 
    the deployment. May contain an arbitrary number of <b><font face="Courier New, Courier, mono">&lt;option 
    name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    value=&quot;</font></b><font face="Courier New, Courier, mono"><i>value</i></font><b><font face="Courier New, Courier, mono">&quot;&gt;</font></b> 
    elements, each of which will supply an option to the deployed Handler.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;service name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    provider=&quot;</font></b><font face="Courier New, Courier, mono"><i>provider</i></font><b><font face="Courier New, Courier, mono">&quot; 
    &gt;</font></b></dt>
  <dd>Deploys/undeploys an Axis Service. This is the most complex WSDD tag, so 
    we're going to spend a little time on it.<br>
    <br>
    <b>Options</b> may be specified as follows : <code><b>&lt;parameter name=&quot;</b>name<b>&quot; 
    value=&quot;</b>value<b>&quot;/&gt;</b></code>, and common ones include:<br>
    <br>
    <ul>
    <li><b>className</b> : the backend implementation class<br>
    <li><b>allowedMethods</b> : 
    Each provider can determine which methods are allowed to be exposed as web services.
    <br>To summaries for Axis supplied providers:<br>
    <p><u>Java RPC Provider</u> (provider="java:RPC") by default all public methods specified by the class
    in the className option, including any inherited methods are 
    available as web services.<br> For more details regarding the Java Provider 
    please see <B>WHERE???</B>.
    <P><u>Java MsgProvder</u> (provider="java:MSG") 
    <!-- Glen to provide details -->
    <P>In order to further restrict the above methods, the <b>allowedMethods</b> option  may
    be used to specify in a space delimited list the names of only those methods which are allowed 
    as web services. It is also possible to specify for this option the value <b>"*"</b> which is
    functionally equivalent to not specify the option at all.
    Also, it is worth mentioning  that the <b>operation</b> element is used to further define the methods being offered, but it does not affect
    which methods are made available.
    <p><i>Note, while this is true for Axis supplied providers,  it is implementation dependent on each individual provider. Please review
    your providers documentation on how or if it supports this option.</i>
   </i> 
   <P>
   <B><u>Note, Exposing any web service has security implications.</u><br></B>As a best practices guide it is
   <u>highly</u> recommend when offering a web service in un secure environment to restrict allowed methods to only those
   required for the service being offered. And, for those that are made available, to <b>fully</b> understand their function
   and how they may access and expose your systems's resources.
   <P>
    <li><b>allowedRoles</b> : comma-separated list of roles allowed to access this 
    service<br>
    </ul>
    <br>
    If you wish to define handlers which should be invoked either before or after 
    the service's provider, you may do so with the <b>&lt;requestFlow&gt;</b> 
    and the <b>&lt;responseFlow&gt;</b> subelements. Either of those elements 
    may be specified inside the <b>&lt;service&gt;</b> element, and their semantics 
    are identical to the <b>&lt;chain&gt;</b> element described below - in other 
    words, they may contain <b>&lt;handler&gt;</b> and <b>&lt;chain</b>&gt; elements 
    which will be invoked in the order they are specified.<br>
    <br>
    Example:<br>
    <pre>&lt;service name=&quot;test&quot;&gt;
  &lt;parameter name=&quot;className&quot; value=&quot;test.Implementation&quot;/&gt;
  &lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
  &lt;namespace&gt;http://testservice/&lt;/namespace&gt;
  &lt;requestFlow&gt; &lt;!-- Run these before processing the request --&gt;
    &lt;handler type=&quot;java:MyHandlerClass&quot;/&gt;
    &lt;handler type=&quot;somethingIDefinedPreviously&quot;/&gt;
  &lt;/requestFlow&gt;
&lt;/service&gt;</pre>
    <b>Metadata</b> may be specified about particular operations in your service 
    by using the &lt;operation&gt; tag inside a service. This enables you to map 
    the java parameter names of a method to particular XML names, to specify the 
    parameter modes for your parameters, and to map particular XML names to particular 
    operations.<br>
    <br>
    &lt;operation name=&quot;method&quot;&gt;<br>
    &lt;/operation&gt; <br>
  </dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;chain name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot;</font></b><b><font face="Courier New, Courier, mono">&gt;<br>
    &lt;<i>subelement</i>/&gt;...<br>
    &lt;/chain&gt; </font></b></dt>
  <dd>Defines a chain. Each <i>handler</i> (i.e. deployed handler name) in the 
    list will be invoked() in turn when the chain is invoked. This enables you 
    to build up &quot;modules&quot; of commonly used functionality. The subelements 
    inside chains may be &lt;<b>handler</b>&gt;s or &lt;<b>chain</b>&gt;s. &lt;handler&gt;s 
    inside a &lt;chain&gt; may either be defined in terms of their Java class:<br>
    <pre>&lt;chain name=&quot;myChain&quot;&gt;
  &lt;handler type=&quot;java:org.apache.axis.handlers.LogHandler&quot;/&gt;
&lt;/chain&gt;</pre>
    or may refer to previously defined &lt;handlers&gt;, with the &quot;type&quot; 
    of the handler referring to the name of the other handler definition:<br>
    <pre>&lt;handler name=&quot;logger&quot; type=&quot;java:org.apache.axis.handlers.LogHandler&quot;/&gt;<br>&lt;chain name=&quot;myChain&quot;/&gt;<br>   &lt;handler type=&quot;logger&quot;/&gt;<br>&lt;/chain&gt;</pre>
  </dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;transport name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot;&gt;</font></b></dt>
  <dd>Defines a transport on the server side. Server transports are invoked when 
    an incoming request arrives. A server transport may define <b>&lt;requestFlow&gt;</b> 
    and/or <b>&lt;responseFlow&gt;</b> elements to specify handlers/chains which 
    should be invoked during the request (i.e. incoming message) or response (i.e. 
    outgoing message) portion of processing (this function works just like the 
    <b>&lt;service&gt;</b> element above). Typically handlers in the transport 
    request/response flows implement transport-specific functionality, such as 
    parsing protocol headers, etc.</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;transport name=&quot;</font></b><font face="Courier New, Courier, mono"><i>name</i></font><b><font face="Courier New, Courier, mono">&quot; 
    pivot=&quot;</font></b><font face="Courier New, Courier, mono"><i>handler 
    type</i><b>&quot;</b></font><b><font face="Courier New, Courier, mono"> &gt;</font></b></dt>
  <dd>Defines a transport on the client side, which is invoked when sending a 
    SOAP message. The &quot;pivot&quot; attribute specifies a Handler to be used 
    as the actual sender for this transport (for example, the HTTPSender). Request 
    and response flows may be specified as in server-side transports to do processing 
    on the request (i.e. outgoing message) or response (i.e. incoming message).</dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;typeMapping qname=&quot;</font></b><font face="Courier New, Courier, mono"><i>ns:localName</i></font><b><font face="Courier New, Courier, mono">&quot; 
    classname=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot; 
    serializer=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot; 
    deserializer=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot;/&gt;</font></b></dt>
  <dd>Each typeMapping maps an XML qualified name to/from a Java class, using 
    a specified Serializer and Deserializer. </dd>
  <dt>&nbsp;</dt>
  <dt><b><font face="Courier New, Courier, mono">&lt;beanMapping qname=&quot;</font></b><font face="Courier New, Courier, mono"><i>ns:localName</i></font><b><font face="Courier New, Courier, mono">&quot; 
    classname=&quot;</font></b><font face="Courier New, Courier, mono"><i>classname</i></font><b><font face="Courier New, Courier, mono">&quot;</font></b><b><font face="Courier New, Courier, mono">&gt;</font></b></dt>
  <dd><b></b>A simplified type mapping, which uses pre-defined serializers/deserializers 
    to encode/decode JavaBeans. The class named by &quot;classname&quot; must 
    follow the JavaBean standard pattern of get/set accessors.</dd>
</dl>
<p> </p>



<a name="global_configuration" />
<h2>Global Axis Configuration</h2>

The server is configured (by default) by values in the
server-config.wsdd file, though a dedicated Axis user can write their
own configuration handler, and so store configuration data in an LDAP
server, database, remote web service, etc. Consult the source on details
as to how to do that. You can also add options to the web.xml file and
have them picked up automatically. We don't encourage that as it is nice
to keep configuration stuff in one place.

<p> 

In the server-config file, there is a global configuration section,
which supports parameter name/value pairs as nested elements. Here are
the options that we currently document, though there may be more
(consult the source, as usual). 

<pre>   &lt;globalConfiguration&gt;
    &lt;parameter name=&quot;adminPassword&quot; value=&quot;admin&quot;/&gt;
    &lt;parameter name=&quot;attachments.Directory&quot; value=&quot;c:\temp\attachments&quot;/&gt;
    &lt;parameter name=&quot;sendMultiRefs&quot; value=&quot;true&quot;/&gt;
    &lt;parameter name=&quot;sendXsiTypes&quot; value=&quot;true&quot;/&gt;
    &lt;parameter name=&quot;attachments.implementation&quot; value=&quot;org.apache.axis.attachments.AttachmentsImpl&quot;/&gt;
    &lt;parameter name=&quot;sendXMLDeclaration&quot; value=&quot;true&quot;/&gt;
    &lt;parameter name=&quot;enable2DArrayEncoding&quot; value=&quot;true&quot;/&gt;
   &lt;/globalConfiguration&gt;
</pre>
<table>
  <tr>
    <td><b>adminPassword</b></td>
    <td>Adminstrator password, as used by AdminService. </td>
  </tr>
  <tr>
    <td><b>attachments.Directory</b></td>
    <td>The directory where attachments end up. This should be in the syntax appropriate 
      for the target platform. </td>
  </tr>
  <tr>
    <td><b>attachments.implementation</b></td>
    <td> Name of class that implements attachments support. Default is <tt>org.apache.axis.attachments.AttachmentsImpl</tt> 
    </td>
  </tr>
  <tr>
    <td><b>axis.enableListQuery</b></td>
    <td>Flag to enable the "list the WSDD" feature. Set to false by default, because 
      listing the current system config can expose information (such as the adminservice 
      password) that one does not want widely avaialable. </td>
  </tr>
  <tr>
    <td><b>axis.Compiler</b></td>
    <td>Compiler adapter classname for JWS compilation. Default is <tt>org.apache.axis.components.compiler.Javac</tt>; 
      change this to <tt>org.apache.axis.components.compiler.Jikes</tt> to invoke 
      jikes instead. </td>
  </tr>
  <tr>
    <td><b>axis.development.system</b></td>
    <td>Flag to switch the system from <i>production</i> (false) to <i>development</i> 
      (true). A development system gives out stack traces and other information 
      that production boxes should not. </td>
  <tr>
    <td><b>axis.engineConfigClass</b></td>
    <td>Name of a class that provides Axis configuration. Implement a new class 
      implementing <tt>EngineConfiguration</tt> and name it here to use alternate 
      configuration mechanisms. </td>
  <tr>
    <td><b>axis.jws.servletClassDir</b></td>
    <td>Path to where compiled JWS pages are placed. </td>
  </tr>
  <tr>
    <td><b>axis.sendMinimizedElements</b></td>
    <td>Flag to turn on support for a when .NET1.0 can't correctly handle some 
      bits of XML <a href="http://nagoya.apache.org/bugzilla/show_bug.cgi?id=17021"> 
      that it should. </a> The flag defaults to true; if some .NET clients are 
      failing to handle a Web Service returning an empty array inside another 
      object, set this flag to <i>false</i>. </td>
  </tr>
  <tr>
    <td><b>enable2DArrayEncoding</b></td>
    <td>Set this to "true" to turn 2D array encoding on; this encoding is incompatible 
      with .NET 1.0: default="false". </td>
  </tr>
  <tr>
    <td><b>sendMultiRefs</b></td>
    <td>true/false flag to control whether multirefs are sent or not. </td>
  </tr>
  <tr>
    <td><b>sendXMLDeclaration</b></td>
    <td>true/false flag to control whether the &lt;?xml?&gt; declaration is sent 
      in messages </td>
  </tr>
  <tr>
    <td><b>sendXsiTypes</b></td>
    <td>true/false flag to enable/disable sending the type of every value sent 
      over the wire. Defaults to true. </td>
  </tr>
  <tr> 
    <td><strong>SingleSOAPVersion</strong></td>
    <td>When set to either &quot;1.1&quot; or &quot;1.2&quot;, this configures 
      the engine to only accept the specified SOAP version. Attempts to connect 
      to the engine using another version will result in a fault.</td>
  </tr>
  <tr>
    <td><b>use-servlet-security</b></td>
    <td>Set this flag to hand authentication off to the servlet container. </td>
  </tr>
  <!-- end table -->
</table>

<a name="individual_service" />
 
<h2>Individual Service Configuration</h2>

<i>TODO</i>
<p>

Here are some of the per-service configuration options are available;
these can be set in the wsdd file used to deploy a service, from where
they will be picked up.
<p> 
More may exist. 

<table>
  <tr>
    <td><b>style</b></td>
    <td>whether to use RPC:enc or doc/lit encoding </td>
  </tr>
  <tr>
    <td><strong>SingleSOAPVersion</strong></td>
    <td>When set to either &quot;1.1&quot; or &quot;1.2&quot;, this configures 
      a service to only accept the specified SOAP version. Attempts to connect 
      to the service using another version will result in a fault.</td>
  </tr>
  <tr>
    <td><b>wsdlFile</b></td>
    <td>The path to a WSDL File; can be an absolute path or a resource that axis.jar 
      can load. Useful to export your custom WSDL file. When specify a path to 
      a resource, place a forward slash to start at the beginning of the classpath 
      (e.g "/org/someone/res/mywsdl.wsdl"). How does Axis know whether to return 
      a file or resource? It looks for a file first, if that is missing a resource 
      is returned. </td>
  </tr>
  <!-- TODO: what does this mean?
 <tr><td><b>streaming</b></td>
<td>
</td>
</tr>
 -->
</table>
<a name="axis_logging" />

<h2>Axis Logging Configuration</h2>

Axis uses the Jakarta Projects's
<a href="http://jakarta.apache.org/commons/logging.html">commons-logging API</a>,
as implemented in <tt>commons-logging.jar</tt> to implement logging throughout the code. Normally
this library routes the logging to the Log4j library, provided that an
implementation of log4j is on the classpath of the server or client. The
commons-logging API can also bind to Avalon, <tt>System.out</tt> or the Java1.4
logger. The JavaDocs for the library explain the process for selecting a logger,
which can be done via a system property or a properties file in the classpath.

<p>

Log4J can be configured using the file log4j.properties in the classpath; later
versions also support an XML configuration. Axis includes a preconfigured
log4j.properties file in <tt>axis.jar</tt>. While this is adequate for basic use,
any complex project will want to modify their own version of the file. Here is
what to do 
<ol>
<li>Open up axis.jar in a zipfile viewer and remove log4j.properties from the jar
<li>Or, when building your own copy of axis.jar, set the Ant property
    <tt>exclude.log4j.configuration</tt> to keep the properties file out the JAR.
<li>Create your own log4J.properties file, and include it in <tt>WEB-INF/classes</tt>
(server-side), in your main application JAR file client side.
<li>Edit this log4J properties file to your hearts content. Server side,
setting up rolling logs with fancy html output is convenient, though once you
start clustering the back end servers that ceases to be as usuable. Log4J power tools,
such as 'chainsaw', are the secret here.
</ol>

<h3>Log Categories</h3>

Axis classes that log information create their own per-class log, each of which
may output information at different levels. For example, the main entry point
servlet has a log called <tt>org.apache.axis.transport.http.AxisServlet</tt>,
the AxisEngine is <tt>org.apache.axis.AxisEngine</tt>, and so on. There are
also special logs for special categories.
<p>
<table border=0>
<tr>
  <td valign=top><tt>org.apache.axis.TIME</tt></td>
  <td>A log that records the time to execute incoming messages, splitting up
  into preamble, invoke, post and send times. These are only logged at debug level.
</tr>
<tr>
  <td valign=top><tt>org.apache.axis.EXCEPTIONS</tt></td>
  <td>Exceptions that are sent back over the wire. AxisFaults, which are normally
  created in 'healthy' operation, are logged at debug level. Other Exceptions
  are logged at the Info level, as they are more indicative of server side trouble.
</tr>
<tr>
  <td valign=top><tt>org.apache.axis.enterprise</tt></td>
  <td>''Enterprise'' level stuff, which generally means  
  stuff that an enterprise product might want to track, but in a 
  simple environment (like the AXIS build) would be nothing more than a nuisance.
  
</tr>
</table>



<a name="axis_components" />

<h2>Pre-Configured Axis Components Reference</h2>
<h3>On the server:</h3>
<dl> 
  <dt><b>SimpleSessionHandler</b>
  <dd>uses SOAP headers to do simple session management
  <dt>&nbsp;
  <dt><b>LogHandler</b> 
  <dd>The LogHandler will simply log a message to a logger when it gets invoked. 
  <dt> 
  <dt><b>SoapMonitorHandler</b>
  <dd>Provides the hook into the message pipeline sending the SOAP request and
  response messages to the SoapMonitor utility.
  <dt>
  <dt><b>DebugHandler</b>
  <dd>Example handler that demonstrates dynamically setting the debug level based on a 
  the value of a soap header element.
  <dt>&nbsp;
  <dt> 
  <dt><b>ErrorHandler</b>
  <dd>Example handler that throws an AxisFault to stop request/response flow processing. 
  <dt>&nbsp;
  <dt> 
  <dt><b>EchoHandler</b> 
  <dd>The EchoHandler copies the request message into the response message. 
  <dt>&nbsp;
  <dt><b>HTTPAuth</b>
  <dd>The HTTPAuthHandler takes HTTP-specific authentication information (right 
    now, just Basic authentication) and turns it into generic MessageContext properties 
    for username and password
  <dt><b>SimpleAuthenticationHandler</b> 
  <dd>The SimpleAuthentication handler passes a MessageContext to a SecurityProvider 
    (see org.apache.axis.security) to authenticate the user using whatever information 
    the SecurityProvider wants (right now, just the username and password).
  <dt><b>SimpleAuthorizationHandler</b> 
  <dd>This handler, typically deployed alongside the SimpleAuthenticationHandler 
    (a chain called &quot;authChecks&quot; is predefined for just this combination), 
    checks to make sure that the currently authenticated user satisfies one of 
    the allowed roles for the target service. Throws a Fault if access is denied.
  <dt>
  <dt><b>MD5AttachHandler</b>
  <dd>Undocumented, uncalled, untested handler that generates an MD5 hash of 
  attachment information and adds the value as an attribute in the soap body.
  <dt>&nbsp;
  <dt><b>URLMapper</b> 
  <dd>The URLMapper, an HTTP-specific handler, usually goes on HTTP transport 
    chains (it is deployed by default). It serves to do service dispatch based 
    on URL - for instance, this is the Handler which allows URLs
    like http://localhost:8080/axis/services/MyService?wsdl 
    to work.
  <dt>&nbsp;
  <dt><b>RPCProvider</b>
  <dd>The RPCProvider is the pivot point for all RPC services. It accepts the
    following options: <br>
    <b><i>className</i></b> = the class of the backend object to invoke<br>
    <b><i>methodName</i></b> = a space-separated list of methods which are exported
    as web services. The special value &quot;*&quot; matches all public methods
    in the class.
  <dt>
  <dt><b>MsgProvider</b>
  <dd>The MsgProvider is the pivot point for all messaging services. It accepts
    the following options: <br>
  <dd><b><i>className</i></b> = the class of the backend object to invoke<br>
    <b><i>methodName</i></b> = a space-separated list of methods which are exported
    as web services. The special value &quot;*&quot; matches all public methods
    in the class.
  <dt>
  <dt><b>JWSHandler</b>
  <dd>Performs drop-in deployment magic.
  <dt>
  <dt><b>JAXRPCHandler</b>
  <dd>Wrapper around JAX-RPC compliant handlers that exposes an Axis handler interface to the engine.
  <dt>&nbsp;
  <dt><b>LocalResponder</b> 
  <dd>The LocalResponder is a Handler whose job in life is to serialize the response 
    message coming back from a local invocation into a String. It is by default 
    on the server's local transport response chain, and it ensures that serializing 
    the message into String form happens in the context of the server's type mappings.</dd>
</dl>
<h3>On the client:</h3>
<dl> 
  <dt><b>SimpleSessionHandler</b>
  <dd>uses SOAP headers to do simple session management
  <dt>&nbsp;
  <dt><b>JAXRPCHandler</b>
  <dd>Wrapper around JAX-RPC compliant handlers that exposes an Axis handler interface to the engine.
  <dt>&nbsp;
  <dt><b>HTTPSender</b> 
  <dd>A Handler which sends the request message to a remote server via HTTP, and 
    collects the response message.
  <dt> 
  <dt><b>LocalSender</b> 
  <dd>A Handler which sends the request message to a &quot;local&quot; AxisServer, 
    which will process it and return a response message. This is extremely useful 
    for testing, and is by default mapped to the &quot;local:&quot; transport. 
    So, for instance, you can test the AdminClient by doing something like this:<br>
    <pre>% java org.apache.axis.client.AdminClient -llocal:// list</pre>
  <dt></dt>
</dl>
</body>
</html>
