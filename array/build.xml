<?xml version="1.0"?>

<!--
 !  ARRAY build file
 !
 !   This file describes how to build the ARRAY package from a source
 !   release. It requires Apache ANT and a Java Development Kit.
 !
 !      build            -> compiles the source code
 !      clean            -> cleans up build and dist products
 !      deinstall        -> undo the install target
 !      dist             -> creates the local binary distribution
 !      export           -> creates the full distribution archives
 !      export-runonly   -> creates the runonly distribution archives
 !      export-source    -> creates the source distribution archives
 !      install          -> install distribution into Starlink tree
 !      install-runonly  -> install a runonly distribution into Starlink tree
 !      jars             -> creates the package jar file
 !      javadocs         -> creates the API documentation
 !      test             -> runs JUnit tests
 !
 !   Authors:
 !      Peter W. Draper (2-JUL-2002)
 !      Mark Taylor (31-JUL-2002)
 !
 !   Version:
 !      $Id$
 !
 !-->

<project name="Build file for ARRAY" default="build" basedir=".">

  <!-- If either or both of these files exist then any properties
   !   contained within them will override those defined here.  -->
  <property file="${user.home}/.stardev.properties"/>
  <property file=".properties"/>

  <!-- Properties will also be set for all environment variables
   !   (PATH becomes "env.PATH"), generally not a good
   !   idea as names are OS dependent -->
  <property environment="env"/>

  <!--
   !  =================
   !  Global Properties
   !  =================
   !-->

  <!-- Directory for the Starlink installation (usually /star/java)-->
  <property name="star.dir" value="${basedir}/../../"/>

  <!-- Directory to install into (install target, usually /star/java)-->
  <property name="star.install" value="${star.dir}"/>

  <!-- Directory that contains the Starlink jar tree -->
  <property name="star.jar.dir" value="${star.dir}/lib"/>

  <!-- Directory that contains the locally built sources (usually
   !   /star/java/source for full distribution) -->
  <property name="star.build.dir" value="${basedir}/../"/>

  <!-- Directory that any archives should be placed into. The local
   !   directory by default -->
  <property name="star.archive.dir" value="${basedir}"/>

  <!-- The environment CLASSPATH is ignored by Ant tasks. -->
  <property name="build.sysclasspath" value="ignore"/>


  <!--
   !  ================
   !  Local Properties
   !  ================
   !-->

  <!-- Define the package name and current versions -->
  <property name="Name" value="ARRAY"/>
  <property name="name" value="array"/>
  <property name="version" value="0.2"/>

  <!-- The Java package name -->
  <property name="package.name" value="uk.ac.starlink"/>

  <!-- Compilation options -->
  <property name="debug" value="true"/>
  <property name="deprecation" value="false"/>
  <property name="optimize" value="true"/>

  <!-- Extra task options, if any -->
  <property name="chmod.fail" value="false"/>

  <!-- JUnit test options -->
  <property name="junit.fork" value="false"/>
  <property name="junit.filtertrace" value="on"/>
  <property name="junit.summary" value="no"/>

  <!-- Directory containing the package source -->
  <property name="src.dir" value="src"/>

  <!-- Directory containing the java source (top of the namespace)-->
  <property name="java.dir" value="${src.dir}/main"/>

  <!-- Directory containing any script required to execute or setup package-->
  <property name="script.dir" value="${src.dir}/script"/>

  <!-- Directory containing any third-party jars that should be
   !   distributed (normally these would belong in a proper package)-->
  <property name="src.jars.dir" value="${src.dir}/lib"/>

  <!-- Directories for JUnit test cases and related files -->
  <property name="tests.dir" value="${src.dir}/testcases"/>
  <property name="tests.etc.dir" value="${src.dir}/etc/testcases"/>

  <!-- File types that should not be passed through a filterchain when
   !   copying -->
  <property name="unfiltered.files" value="**/*.gif,**/*.jpg,**/*.ico"/>

  <!-- Directories to receive the various build components -->
  <property name="build.dir" value="build"/>
  <property name="build.classes" value="${build.dir}/classes"/>
  <property name="build.java" value="${build.dir}/java"/>
  <property name="build.jni" location="${build.dir}/jni"/>
  <property name="build.lib" value="${build.dir}/lib"/>
  <property name="build.javadocs" value="${build.dir}/javadocs"/>
  <property name="build.tests" value="${build.dir}/testcases"/>
  <property name="build.tests.javadocs" value="${build.dir}/javadocs.test/"/>

  <!-- Distribution directories, these are created in the current
   !   directory, unless dist.dir is redefined. Files that will be
   !   installed under a package name prefixed directory should be
   !   placed in the ".pkg" variants -->
  <property name="dist.dir" value="${basedir}"/>

  <property name="dist.bin" value="${dist.dir}/bin"/>
  <property name="dist.lib" value="${dist.dir}/lib"/>
  <property name="dist.src" value="${dist.dir}/src"/>
  <property name="dist.docs" value="${dist.dir}/docs"/>
  <property name="dist.etc" value="${dist.dir}/etc"/>

  <property name="dist.bin.pkg" value="${dist.dir}/bin/${name}"/>
  <property name="dist.lib.pkg" value="${dist.dir}/lib/${name}"/>
  <property name="dist.docs.pkg" value="${dist.dir}/docs/${name}"/>
  <property name="dist.etc.pkg" value="${dist.dir}/etc/${name}"/>
  <property name="dist.javadocs" value="${dist.dir}/docs/${name}/javadocs"/>

  <!-- Version for zipped/tarred export files. -->
  <property name="dist.version" value="${name}-${version}"/>

  <!-- File for logging the files that are copied by the install target -->
  <property name="install.log" value=".${name}.install"/>
  <property name="install.overwrite" value="true"/>

  <!-- Add any local ANT tasks that are required (these should be
   !   moved to ANT if useful beyond the needs of this package) -->

  <!-- Non-standard source file directories -->
  <property name="src.perl" value="${src.dir}/perl"/>

  <!-- Non-standard build file directories -->
  <property name="build.java" value="${build.dir}/java"/>

  <!-- Non-standard files -->
  <property name="perl" value="/stardev/Perl/bin/perl"/>


  <!--
   !   =========
   !   CLASSPATH
   !   =========
   !-->

  <!-- Name all the jar files that we directly depend on. These will be
   !   used to produce a full CLASSPATH that is equivalent to that
   !   generated when these are referenced as optional bundled packages.
   !   It's best to have a classpath (rather than use the extension
   !   mechanism) during development as this allows us to compile
   !   without having to work these dependencies out anyway (may
   !   be fixed in Java1.5) plus we can execute against locally build
   !   class files in preference to installed ones (an externally
   !   defined CLASSPATH can also be used as needed).
   !-->
  <extclasspath id="installed.classpath">

    <!-- Util -->
    <pathelement location="${star.jar.dir}/util/util.jar"/>

    <!-- FITS - optional -->
    <pathelement location="${star.jar.dir}/fits/fits.jar"/>

    <!-- HDS - optional -->
    <pathelement location="${star.jar.dir}/hds/hds.jar"/>

  </extclasspath>

  <!-- Generate the local build classpath. This is the most difficult
   !   part of handling the classpath. The local classes will be in
   !   the "build/classes" part of each package, plus third party
   !   packages will have their jar files in the "dist" directories.
   !   Having the third party jars not installed means that the
   !   building a classpath based on their manifest class-paths will
   !   not resolve all references (these may be to other third party
   !   jars, that are normally resolved using relative URLs). The way
   !   that this is resolved is simply to locate all "build/classes"
   !   directories and all jar files in the "dist" parts and just add
   !   these all to the classpath. Known third party dependencies are
   !   added after the "build/classes" directories using the
   !   "extclasspath" type, just so that they will be referred to
   !   first. If this doesn't work as expected add the additional
   !   classes/jars to the external classpath.
   !-->
  <extclasspath id="built.jarpath">

    <pathelement location="${star.build.dir}/util/lib/util/util.jar"/>
    <pathelement location="${star.build.dir}/fits/lib/fits/fits.jar"/>
    <pathelement location="${star.build.dir}/hds/lib/hds/hds.jar"/>

  </extclasspath>

  <path id="built.classpath">

    <!-- All locally built classes -->
    <dirset dir="${star.build.dir}">
      <include name="*/build/classes"/>
    </dirset>

    <!-- Directly dependent third party jars -->
    <path refid="built.jarpath"/>

    <!-- Finally add all "dist" jar files to make sure everything is
     !   resolved, including relative URLs out of the local package -->
    <fileset dir="${star.build.dir}">
      <include name="*/lib/*/*.jar"/>
    </fileset>

    <!-- Note in passing a more elegant way to resolve these jars
     !   would be to extend <extclasspath> to go looking for dependent
     !   jars using an additional resolving mechanism-->

  </path>

  <!-- CLASSPATH defined in the external environment -->
  <path id="local.classpath" path="${java.class.path}"/>

  <!-- Unification of all classpaths using local, built, installed order-->
  <path id="classpath">
    <path refid="local.classpath"/>
    <path refid="built.classpath"/>
    <path refid="installed.classpath"/>
  </path>

  <!-- JUnit tests classpath -->
  <path id="tests-classpath">
    <pathelement location="${build.classes}"/>
    <pathelement location="${build.tests}"/>
    <pathelement location="${tests.dir}"/>
    <pathelement location="${tests.etc.dir}"/>
    <path refid="classpath"/>
  </path>

  <!-- Turn this path into a string which is passed to the tests -->
  <property name="tests-classpath.value" refid="tests-classpath"/>

  <!--
   !    =========================================
   !    Check availability of direct dependencies
   !    =========================================
   !    (could also use this to check optional elements).
   !
   ! If any of the required dependencies are not present then
   ! this throws a <fail> and exits the build.
   !-->
  <target name="check_packages"
          unless="runonly.install">

    <!-- Need Util -->
    <available property="util.present"
               classpathref="classpath"
               classname="uk.ac.starlink.util.GenericNioBuffer"/>
    <fail message="No Util available" unless="util.present"/>

    <!-- Need JUnit for testcases, not essential -->
    <condition property="testframework.present">
      <and>
        <available classpathref="tests-classpath"
                   classname="junit.framework.TestCase"/>
        <available classpathref="tests-classpath"
                   classname="uk.ac.starlink.util.TestCase"/>
      </and>
    </condition>

    <!-- HDS and FITS, while desirable, are not required 
         (they are installed at runtime if present) -->

  </target>

  <!--
   !   =================
   !   Prepare the build
   !   =================
   !
   !  Do any jobs that are required before any other target can proceed.
   !-->
  <target name="prepare">

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>

    <!-- This is a filterchain that can be used to copy-edit files
     !   that require the package version, current date and/or time -->
    <filterchain id="filters">
      <replacetokens>
        <token key="VERSION" value="${version}"/>
        <token key="DATE" value="${TODAY}"/>
        <token key="TIME" value="${TSTAMP}"/>
      </replacetokens>
    </filterchain>

  </target>


  <!--
   !   ==============
   !   Build the code
   !   ==============
   !
   !  The results of the compilation are placed in the build.classes
   !  directory. Other files that are also needed in the classes tree
   !  (i.e. resources like images) should also be copied into place here.
   !-->
  <target name="build"
          depends="prepare, check_packages, build_classes"
          unless="runonly.install"
          description="-> compiles the source code">

    <!-- Copy extra files that should live with packages classes
     !   (i.e. are discovered using "getResource()"). -->
    <copy todir="${build.classes}">
      <fileset dir="${java.dir}" includes="[none]"/>
    </copy>

    <!-- Local third party jars, if any. Copy straight into
     !   distribution directories to save on unnecessary copies and to
     !   make these available for resolution by other locally built
     !   packages that are using this one -->
    <!--
     !  <mkdir dir="${dist.lib.pkg}"/>
     !  <copy todir="${dist.lib.pkg}">
     !    <fileset dir="{$src.jars.dir}" includes="[none]"/>
     !  </copy>
    -->

  </target>


  <!-- Build the java class files. -->
  <target name="build_classes" depends="assemble_java">
    <mkdir dir="${build.classes}"/>
    <javac srcdir="${build.java}"
           destdir="${build.classes}"
           debug="${debug}"
           deprecation="${deprecation}"
           optimize="${optimize}">

      <classpath refid="classpath"/>

      <!-- Exclude any Java files in the source tree that should not be
       !   compiled -->
      <exclude name="**/retired_code/*"/>
      <exclude name="**/*Test*"/>
    </javac>
  </target>


  <!--
   !   Put all the java source files in the build directory.
   !   Some of these are copied direct from the source directory, some
   !   are generated from perl source.
   !-->
  <target name="assemble_java" unless="java.assembled">

    <mkdir dir="${build.java}"/>

    <copy todir="${build.java}">
      <fileset dir="${java.dir}">
        <include name="**/*.java"/>
        <include name="**/*.html"/>
      </fileset>
    </copy>

    <!-- .pl files are executed to create .java files at the same place
     !   in the hierarchy.  The perl files in question must take a 
     !   sole argument giving the name of the output file.
     !-->
    <apply executable="${perl}" dest="${build.java}" failonerror="true">
      <srcfile/>
      <targetfile/>
      <fileset dir="${src.perl}" includes="**/*.pl"/>
      <mapper type="glob" from="*.pl" to="*.java"/>
    </apply>

  </target>

  <!--
   !   ============================
   !   Create the package jar files
   !   ============================
   !
   !  Creates a jar file from the build.classes directory tree. If
   !  jars of components are also required these should be created
   !  here too. Note this requires a manifest file that defines the
   !  jars that we directly depend on (using relative URLs).
   !  Builds a jar of the java source too.
   !-->
  <target name="jars"
          depends="build"
          unless="runonly.install"
          description="-> creates the package jar file">

    <mkdir dir="${build.lib}"/>
    <jar destfile="${build.lib}/${name}.jar" basedir="${build.classes}">
      <manifest>
        <attribute name="Built-By" value="${user.name}"/>
        <attribute name="Class-Path" 
                   value="../junit/junit.jar ../util/util.jar"/>
      </manifest>
    </jar>

    <zip destfile="${build.lib}/${name}_src.zip" basedir="${build.java}"/>

  </target>

  <!--
   !   =============================
   !   Create the local distribution
   !   =============================
   !
   !  Creates a local distribution in the directory "dist.dir"
   !  (usually the current directory). Installations are based on this
   !  distribution. If the "runonly.install" parameter is set then this
   !  target is skipped (needed for releases that do not have source).
   !-->
  <target name="dist"
          depends="build,jars,javadocs"
          unless="runonly.install"
          description="-> creates the local binary distribution">

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <copy todir="${dist.lib.pkg}">
      <fileset dir="${build.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
      </fileset>
    </copy>

    <copy todir="${dist.lib}">
      <fileset dir="${build.lib}" includes="**/*.so"/>
    </copy>

    <copy todir="${dist.javadocs}">
      <fileset dir="${build.javadocs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </copy>

    <copy todir="${dist.javadocs}" filtering="false">
      <fileset dir="${build.javadocs}" includes="${unfiltered.files}"/>
    </copy>

    <!-- Set permissions on contents of distribution directory -->
    <chmod perm="ugo+rx" dir="${dist.dir}" type="dir" includes="**"
           failonerror="${chmod.fail}"/>
    <chmod perm="ugo+r" dir="${dist.dir}" type="file" includes="**"
           failonerror="${chmod.fail}"/>

  </target>

  <!--
   !   ========================
   !   Create the full releases
   !   ========================
   !
   !  Creates the full "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target and the source directory.
   !  The archives are designed to be unpacked such that the resultant
   !  directory layout can be either used as a local distribution, or
   !  installed into a Starlink tree (installation requires the
   !  Starlink modified version of ANT, use as a local distribution
   !  may need special handling of the extension path). This version
   !  can also be used to rebuild the package from source.
   !
   !  The archive names are ${dist.version}.<ext>.
   !-->
  <target name="export"
          description="-> creates the full distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}"/>
    </antcall>

  </target>

  <!--
   !   ==========================
   !   Create the source releases
   !   ==========================
   !
   !  Creates the source only "zip", "tar" and "bzip" archives.
   !  These can be used to rebuild the package (requires the Starlink
   !  modified version of ANT).
   !
   !  The archive names are ${dist.version}-src.<ext>.
   !-->
  <target name="export-source"
          description="-> creates the source distribution archives">

    <antcall target="create_archives">
      <param name="source.required" value="true"/>
      <param name="archive.name" value="${dist.version}-src"/>
    </antcall> 

  </target>

  <!--
   !   ===========================
   !   Create the runonly releases
   !   ===========================
   !
   !  Creates the runonly "zip", "tar" and "bzip" archives of the
   !  products of the "dist" target. The archives are designed to be
   !  unpacked such that the resultant directory layout can be either
   !  used as a local distribution, or installed into a Starlink tree
   !  (installation requires the Starlink modified version of ANT).
   !
   !  The archive names are ${dist.version}-bin.<ext>.
   !-->
  <target name="export-runonly"
          description="-> creates the runonly distribution archives">

    <antcall target="create_archives">
      <param name="binary.required" value="true"/>
      <param name="archive.name" value="${dist.version}-bin"/>
    </antcall>

  </target>

  <!--
   ! Create release archives of the various types required. Use this
   ! by an <antcall> and set the property "archive.name" to define what
   ! name to use for the outfile files. The archives are written into
   ! the directory ${star.archive.dir} (the local directory by default).
   !
   ! If the property "binary.required" is set then the files needed
   ! for a run-only release are included and if "source.required" is
   ! defined the source code is also included.
   !
   ! For binary archives which contain platform-dependent code (e.g.
   ! shareable libraries) the operating system name is appended to
   | the archive name.
   !-->
  <target name="create_archives"
          depends="dist">

    <mkdir dir="${star.archive.dir}"/>

    <zip destfile="${star.archive.dir}/${archive.name}.zip">

      <!-- All releases have the documentation and build file -->
      <zipfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <zipfileset dir="${dist.dir}" includes="build.xml" prefix="${name}"/>

      <zipfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </zipfileset>

      <zipfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </zipfileset>

    </zip>

    <!-- Note: creating a tar file with empty directories doesn't
     !   work, so the directory structure may be incomplete -->
    <property name="tarfile.name" value="${archive.name}.tar"/>
    <tar longfile="gnu" destfile="${tarfile.name}">

      <!-- All releases have the documentation and build file -->
      <tarfileset dir="${dist.docs}" prefix="${name}/docs"/>
      <tarfileset dir="${dist.dir}" prefix="${name}">
        <include name="build.xml"/>
      </tarfileset>

      <tarfileset dir="${dist.lib}" prefix="${name}/lib">
        <include name="**" if="binary.required"/>
      </tarfileset>

      <tarfileset dir="${src.dir}" prefix="${name}/src">
        <include name="**" if="source.required"/>
      </tarfileset>
    </tar>

    <gzip zipfile="${star.archive.dir}/${tarfile.name}.gz" 
          src="${tarfile.name}"/>
    <bzip2 zipfile="${star.archive.dir}/${tarfile.name}.bz2"
           src="${tarfile.name}"/>
    <delete file="${tarfile.name}"/>

  </target>

  <!--
   !   ============================================
   !   Cleans up build and distribution directories
   !   ============================================
   !-->
  <target name="clean"
          description="-> cleans up build and dist products">

    <delete dir="${build.dir}"/>
    <delete dir="${dist.bin}"/>
    <delete dir="${dist.lib}"/>
    <delete dir="${dist.docs}"/>
    <delete dir="${dist.etc}"/>

  </target>

  <!--
   !   ================================
   !   Install into the "Starlink" tree
   !   ================================
   !
   ! Installs the "dist" target products into another set of
   ! directories.
   !
   ! An installed system is potentially "undoable" as the copied names
   ! and package-specific directories are logged to "${install.log}".
   !-->
  <target name="install"
          depends="dist"
          description="-> install distribution into Starlink tree">

    <!-- Installation based directories (based on "star.install")-->
    <property name="star.bin" value="${star.install}/bin"/>
    <property name="star.lib" value="${star.install}/lib"/>
    <property name="star.etc" value="${star.install}/etc"/>
    <property name="star.docs" value="${star.install}/docs"/>
    <property name="star.bin.pkg" value="${star.bin}/${name}"/>
    <property name="star.lib.pkg" value="${star.lib}/${name}"/>
    <property name="star.etc.pkg" value="${star.etc}/${name}"/>
    <property name="star.docs.pkg" value="${star.docs}/${name}"/>
    <mkdir dir="${star.install}"/>
    <mkdir dir="${star.lib.pkg}"/>
    <mkdir dir="${star.docs.pkg}"/>

    <loggedcopy todir="${star.lib}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="false">
      <fileset dir="${dist.lib}">
        <include name="**/*.jar"/>
        <include name="**/*.zip"/>
        <include name="**/*.so"/>
      </fileset>
    </loggedcopy>

    <!-- Also remove the package-specific directory. 
     !   Note exact format is required.-->
    <echo file="${install.log}" append="true">${star.lib.pkg}
</echo>

    <loggedcopy todir="${star.docs}"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" excludes="${unfiltered.files}"/>
      <filterchain refid="filters"/>
    </loggedcopy>

    <loggedcopy todir="${star.docs}" filtering="false"
                logfile="${install.log}"
                overwrite="${install.overwrite}"
                logfileAppend="true">
      <fileset dir="${dist.docs}" includes="${unfiltered.files}"/>
    </loggedcopy>
    <echo file="${install.log}" append="true">${star.docs.pkg}
</echo>


  </target>

  <!--
   !   ========================================
   !   Install runonly into the "Starlink" tree
   !   =========================================
   !
   ! Do an install using only the contents of a binary release (a
   ! source-free runonly system).
   !-->
  <target name="install-runonly"
          description="-> install a runonly distribution into Starlink tree">

    <!-- Make sure that the expected file structure exists, some
         of these files can be missing if originally empty -->
    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.pkg}"/>
    <mkdir dir="${dist.docs.pkg}"/>

    <!-- Do normal install, but with many targets switched off-->
    <antcall target="install">
      <param name="runonly.install" value="true"/>
      <param name="javadoc.notrequired" value="true"/>
    </antcall>

  </target>

  <!--
   !   ===================================
   !   De-install from the "Starlink" tree
   !   ===================================
   !
   ! Uses the content of the "${install.log}" to remove the files
   ! that were copied into place by the install target.
   !-->
  <target name="deinstall"
          description="-> undo the install target">

    <loadfile property="files" srcFile="${install.log}"/>
    <listdelete>
      <filelist dir="/" files="${files}"/>
    </listdelete>

    <delete file="${install.log}" failonerror="false"/>

  </target>


  <!--
   !   =============================
   !   Creates the API documentation
   !   =============================
   !
   !  The documentation is created from the Java sources. Should also
   !  extend this to include the possibility of other miscellaneous
   !  documentation (FAQs etc.).
   !-->
  <target name="javadocs"
          depends="prepare,javadoc_check"
          unless="javadoc.notrequired"
          description="-> creates the API documentation">

    <mkdir dir="${build.javadocs}"/>
    <javadoc useexternalfile="yes"
             destdir="${build.javadocs}"
             author="true"
             version="true"
             locale="en"
             windowtitle="${Name} API"
             doctitle="${Name}"
             classpath="classpath">

      <!-- Exclude broken and test files etc. from the document -->
      <fileset dir="${build.java}" defaultexcludes="yes"/>

      <group title="${Name} API" packages="${package.name}*"/>

      <bottom>Copyright &#169; ${year} \\
              CLRC: Central Laboratory of the Research Councils.
              All Rights Reserved.</bottom>
    </javadoc>

  </target>

  <!-- This checks if the javadocs are up to date with respect to the
   !   java source, if so then the "javadoc.notrequired" variable is
   !   set true. Note this is check is not performed if
   !   javadoc.notrequired is already set (by .properties) -->
  <target name="javadoc_check"
          unless="javadoc.notrequired">

    <uptodate property="javadoc.notrequired"
              targetfile="${build.javadocs}/packages.html" >
        <srcfiles dir= "${build.java}" includes="**/*.java"/>
    </uptodate>

  </target>

  <!--
   !   =================
   !   Compile testcases
   !   =================
   !-->
  <target name="compile-tests"
          depends="build"
          if="testframework.present">
    <mkdir dir="${build.tests}"/>

    <javac srcdir="${tests.dir}"
           destdir="${build.tests}"
           debug="${debug}"
           deprecation="${deprecation}" >
      <classpath refid="tests-classpath"/>
    </javac>
  </target>

  <!--
   !   ============
   !   Run testcase
   !   ============
   !-->
  <target name="test"
          depends="run-tests"
          description="-> run JUnit tests"/>

  <target name="run-tests"
          depends="compile-tests"
          if="testframework.present">

    <junit printsummary="${junit.summary}" haltonfailure="yes"
           filtertrace="${junit.filtertrace}"
           fork="${junit.fork}">
      <classpath refid="tests-classpath"/>

      <sysproperty key="java.library.path" value="${dist.lib}"/>
      <sysproperty key="java.io.tmpdir" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>

      <formatter type="plain" usefile="false"/>

      <batchtest>
        <fileset dir="${tests.dir}">
          <include name="**/*Test*"/>
          <exclude name="uk/ac/starlink/TestCase.java"/>
        </fileset>
      </batchtest>

    </junit>
  </target>

  <target name="run-single-test"
          if="testcase"
          depends="compile-tests"
          description="-> runs the single unit test defined in the testcase property">

    <junit printsummary="${junit.summary}"
          haltonfailure="yes"
          fork="${junit.fork}"
          filtertrace="${junit.filtertrace}">
      <sysproperty key="java.library.path" value="${dist.lib}"/>
      <sysproperty key="java.io.tmpfile" value="${build.tests}"/>
      <sysproperty key="build.tests" value="${build.tests}"/>
      <sysproperty key="tests-classpath.value"
                   value="${tests-classpath.value}"/>
      <classpath refid="tests-classpath"/>
      <formatter type="plain" usefile="false"/>
      <test name="${testcase}"/>
    </junit>
  </target>

  <!--
   ! Get a DTD for this build file. Documentation suggests may be incomplete!
   !
   ! Use:
   !
   !    <!DOCTYPE project PUBLIC "-//ANT//DTD project//EN" "./project.dtd">
   !
   ! at head of document to include.
   !-->
  <target name="dtd">
     <antstructure output="project.dtd"/>
  </target>

</project>
